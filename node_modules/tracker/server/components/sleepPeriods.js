/**
 * sleep period
 * sleepTime sleep length of one day
 * sleepMoment the time go to bed
 * wakeMoment the time woke
 */
'use strict';


var Q = require('q');

//var Search = require('../../search/search');
//var statist = require('../../statist');
//var helper = require('../../helper');
var Stat = require('../../model/Stat');

var Moment = require('moment');
var _ = require('lodash');

var timeFormat = 'YYYY-MM-DD HH:mm:ss';
exports.generate = function (options) {
    var deferred = Q.defer();
    var queryConditions = {};
    if (options.start && options.end) {
        queryConditions.date = {
            $gte: Moment(options.start).startOf('day').toDate(),
            $lt: Moment(options.end).endOf('day').toDate()
        };

        Stat.find(queryConditions, null).sort({date: 1}).exec(function (err, results) {
            if (err) {
                return deferred.reject(err);
            }
            deferred.resolve(results.map(function (stat) {
                var result = stat.result;
                return {
                    date: result.date,
                    sleepMoment: new Moment(result.sleepMoment).format(timeFormat),
                    wakeMoment: new Moment(result.wakeMoment).format(timeFormat),
                    sleepTime: result.sleepTime
                };
            }));
        });

    } else {
        deferred.reject({message: 'do not have start and end params'});
    }
    /*Stat.query()
        .then(function (queryResult) {
            var sleepPeriods = [];
            var days = helper.megerLogsToDateType(queryResult, 'day');
            var statResult = statist.dispose(options, {
                days: days
            });
            statResult.days.forEach(function (day) {
                sleepPeriods.push({
                    date: day.date,
                    sleepMoment: new Moment(day.sleepMoment).format(timeFormat),
                    wakeMoment: new Moment(day.wakeMoment).format(timeFormat),
                    sleepTime: day.sleepTime
                });
            });
            sleepPeriods = _.sortBy(sleepPeriods, function (day) {
                return day.date;
            });
            deferred.resolve(sleepPeriods);
        }).catch(function (err) {
            deferred.reject(err);
        });*/
    return deferred.promise;
};
