/**
 * sleep period
 * sleepTime sleep length of one day
 * sleepMoment the time go to bed
 * wakeMoment the time woke
 */
'use strict';


var Q = require('q');

var Search = require('../../search/search');
var statist = require('../../statist');
var helper = require('../../helper');

var Moment = require('moment');
var _ = require('lodash');

var timeFormat = 'YYYY-MM-DD HH:mm:ss';
exports.generate = function (options) {
    var deferred = Q.defer();
    Search.query(options)
        .then(function (queryResult) {
            var sleepPeriods = [];
            var days = helper.megerLogsToDateType(queryResult, 'day');
            var statResult = statist.dispose(options, {
                days: days
            });
            statResult.days.forEach(function (day) {
                sleepPeriods.push({
                    date: day.date,
                    sleepMoment: new Moment(day.sleepMoment).format(timeFormat),
                    wakeMoment: new Moment(day.wakeMoment).format(timeFormat),
                    sleepTime: day.sleepTime
                });
            });
            sleepPeriods = _.sortBy(sleepPeriods, function (day) {
                return day.date;
            });
            deferred.resolve(sleepPeriods);
        }).catch(function (err) {
            deferred.reject(err);
        });
    return deferred.promise;
    /*
    scanner.scan(options)
        .then(function (scanResult) {
            var result = [];
            scanResult.days.forEach(function (day) {
                var dayOptions = extend({}, options, {
                    dateStr: day.date,
                    dateType: dateTypeEnum.Day
                });
                var statResult = dayStat.dispose(dayOptions, day);
                if (!statResult.sleepMoment) {
                    Msg.error(day.date + 'have no sleepTime');
                }
                if (!statResult.wakeMoment) {
                    Msg.error(day.date + 'have no wakeTime');
                }
                result.push({
                    date: day.date,
                    sleepMoment: new Moment(statResult.sleepMoment).format(timeFormat),
                    wakeMoment: new Moment(statResult.wakeMoment).format(timeFormat),
                    sleepTime: statResult.sleepTime
                });
            });
            deferred.resolve(result);
        });
    return deferred.promise;*/
};
