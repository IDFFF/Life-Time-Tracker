'use strict';

var express = require('express');
var http = require('http');
var _ = require('lodash');
var Q = require('q');
var bodyParser = require('body-parser');
var multer = require('multer');
var app = express();
var fs = require('fs');
var path = require('path');

app.use(bodyParser.json()); // for parsing application/json
app.use(bodyParser.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded
var staticDir = path.resolve(__dirname, '../../../');
app.use(express.static(staticDir));
app.use(multer()); // for parsing multipart/form-data

var execute = require('../execute');
var calandar = require('../calendar');
var extend = require('extend');
var stat  = require('./components/stat');
var Param = require('../param');
var logAttr = require('./components/logAttribute');
var Search = require('../search/search');
var SearchProject = require('../search/searchProject');
var Moment = require('moment');
var evernoteSync = require('../../tracker/sync/evernote');
var BackUp = require('../backup/backup');
var Exporter = require('../exporter');
var SearchTask = require('../search/searchTask');
var SearchVersion = require('../search/searchVersion');
var SearchTag = require('../search/searchTag');
var ClassesTrend = require('../statists/classTrend');
var Importer = require('../importer');
var logFileHelper = require('../logFileHelper.js');



var Msg = require('../message');
var Task = require('../model/Task');
var Project = require('../model/project');
var Version = require('../model/version');
var LogClass = require('../model/LogClass');
var Log = require('../model/log');
var Affect = require('../model/Affect');
var AffectRecord = require('../model/AffectRecord');
var Goal = require('../model/Goal');
var config = require('../conf/config');
var serverPort = config.get('serverPort');



var server;

app.get('/actions/:actionName', function(req, res) {
    var actionName = req.params.actionName;
    execute.exec('ltt action ' + actionName + ' --cups 1');
    res.status(200).send('done');
});


app.get('/appInfo', function (req, res) {
    Q.spread([
        count(Project),
        count(Task),
        count(Log)
    ], function (pC, tC, lC) {
        res.status(200).send({
            projectCount: pC,
            taskCount: tC,
            logCount: lC
        });
    }).fail(function (err) {
        console.error(err.stack);
        res.status(500).send({success: false, err: err});
    });

    function count(Model) {
        var deferred = Q.defer();
        Model.count({}, function (err, count) {
            if (err) {
                return deferred.reject(err);
            }
            return deferred.resolve(count);
        });
        return deferred.promise;
    }
});

app.post('/tasks/:id', function (req, res) {
    var params = req.params;

    var taskId = params.id;
    if (taskId) {
        var data = req.body;
        for (var i in data) {
            if (data[i] === 'null') {
                data[i] = null;
            }
        }
        Task.findByIdAndUpdate(taskId, data, function (err, task) {
            if (err) {
                Msg.error('update task failed', err);
                res.status(507).send({success: false, err: err});
                return;
            }
            res.status(200).send(task);
        });
    }
});


app.delete('/tasks/:id', function (req, res) {
    var params = req.params;

    var taskId = params.id;
    if (taskId) {
        Task.findByIdAndRemove(taskId, function (err, result) {
            if (err) {
                Msg.error('delete task failed', err);
                return res.status(500).send({success: false, err: err});
            }
            if (result) {
                Task.remove({
                    parent: taskId
                }, function (err, affectedCount) {
                    if (err) {
                        Msg.error('delete task\'s subTask failed', err);
                        return res.status(500).send({success: false, err: err});
                    }
                    res.status(200).send({task: result, subTaskCount: affectedCount});
                });
            } else {
                res.status(200).send({success: false, err: 'task not exist'});
            }
        });
    } else {
        res.status(500).send({success: false, err: 'need taskId'});
    }
});


app.delete('/versions/:id', function (req, res) {
    var params = req.params;
    var versionId = params.id;
    if (versionId) {
        Version.findByIdAndRemove(versionId, function (err, result) {
            if (err) {
                Msg.error('delete version failed', err);
                return res.status(500).send({success: false, err: err});
            }
            if (result) {
                Task.remove({
                    versionId: versionId
                }, function (err, affectedCount) {
                    if (err) {
                        Msg.error('delete version\'s task failed', err);
                        return res.status(500).send({success: false, err: err});
                    }
                    res.status(200).send({version: result, taskCount: affectedCount});
                });
            } else {
                return res.status(200).send({success: false, err: 'version not exist'});
            }
        });
    }
});

app.get('/affects', function (req, res) {
    Affect.aggregate({
            $group: { _id : "$type", affects: { $push: "$$ROOT" } }
        }).exec(function (err, affectGroups) {
            var result = {};
            affectGroups.forEach(function (group) {
                result[group._id] = group.affects;
            });
            if (err) {
                return res.status(500).send({message: 'load fail', error: err});
            }
            return res.status(200).send(result);
        });
});

app.post('/affects', function (req, res) {
    var affect = req.body;
    var affectName = affect.name;
    var affectType = affect.type;
    if (affectName) {
        affectName = affectName.trim();
    }
    if (!affectName) {
        return res.status(500).send({message: 'have no affect name'});
    }
    if (affectType !== 'N' && affectType !== 'P') {
        return res.status(500).send({message: 'affect type is illegle'});
    }
    Affect.create(affect, function (err, result) {
        if (err) {
            return res.status(500).send({message: 'create fail', error: err});
        }
        res.status(200).send(result);
    });
});

app.post('/affectRecords', function (req, res) {
    var record = req.body;
    var affectRecords = [];
    var createTime = new Date();
    _.each(record, function (val, index) {
        affectRecords.push({
            affect: index,
            score: val,
            createTime: createTime
        });
    });
    AffectRecord.create(affectRecords, function (err) {
        if (err) {
            return res.status(500).send({message: 'create affect record failed', error: err});
        }
        var result = [];
        for (var i = 1; i < arguments.length; ++i) {
            result.push(arguments[i]);
        }
        res.status(200).send(result);
    });
});

app.get('/affectRecords', function (req, res) {
    var query = req.query;
    var fromMoment = new Moment(query.from);
    var toMoment = new Moment(query.to);
    var conditions = {
        affect: query.affectId,
        createTime: {
            $gte: fromMoment.toDate(),
            $lt: toMoment.toDate()
        }
    };
    AffectRecord.find(conditions)
        .sort({createTime: 1})
        .exec(function (err, records) {
        if (err) {
            return res.status(500).send({message: 'load fail', error: err});
        }
        res.status(200).send(records);
    });
});

app.delete('/projects/:id', function (req, res) {
    var params = req.params;
    var projectId = params.id;
    if (projectId) {
        Project.findByIdAndRemove(projectId, function (err, result) {
            if (err) {
                return res.status(500).send({success: false, err: err});
            }
            Q.spread([
                Version.remove({projectId: projectId}).exec(),
                Task.remove({projectId: projectId}).exec(),
            ], function (removeVersionCount, removeTaskCount) {
                res.status(200).send({
                    success: true,
                    removeTaskCount: removeTaskCount,
                    removeVersionCount: removeVersionCount
                });
            }).fail(function (err) {
                res.status(500).send({success: false, message: err.message, err: err});
            });
        });
    }
});

app.post('/backUpLogFile', function (req, res) {
    var body = req.body;
    evernoteSync.backUpLogFile(body.date, body.content).then(function () {
        res.status(200).send({success: true});
    }).fail(function (err) {
        res.status(507).send({success: false, err: err});
    });
});


app.post('/importLogContent', function (req, res) {
    var body = req.body;

    logFileHelper.writeLogFile(body.date, body.logContent)
    .then(function () {
        return Importer.importLogContent(body.date, body.logContent);
    }).then(function () {
        res.status(200).send({success: true});
    }).catch(function (err) {
        console.log(err.message, err.stack, body.date, body.logContent);
        res.status(507).send({success: false, err: err});
    });
});


app.get('/backUpLogFileByDate', function (req, res) {
    var query = req.query;
    var date = query.date;
    if (!date) {
        return res.status(507).send({success: false, err: {message: 'date required'}});
    }
    date = new Moment(date).format('YYYY-MM-DD');
    evernoteSync.backUpLogFileByDate(date).then(function () {
        res.status(200).send({success: true});
    }).fail(function (err) {
        res.status(507).send({success: false, err: err});
    });
});

get('calendars', null, calandar);
get('stats', '/:year?/:month?/:day?', stat);
get('sleepPeriods', null);
get('classes', getLogAttr);
get('projects', '/:id?', queryProjects);
get('versions', '/:id?', queryVersions);
get('tasks', '/:id?', queryTasks);
get('tags', null, queryTags);
get('logs', '/:year?/:month?/:day?', queryLogs);
get('syncNote', null, syncNote);
get('backupNote', null, backupNote);
get('exportNote', null, exportNote);
get('classesTrend', null, function (params) {
    return ClassesTrend.query(params);
});
get('checkSyncStatus', null, function () {
    return evernoteSync.checkSyncStatus();
});



app.get('/goals', function (req, res) {
    Goal.find().exec(function (err, goals) {
        if (err) {
            return res.status(500).send({message: 'load goal failed', error: err});
        }
        return res.status(200).send(goals);
    });
});

app.post('/goals', function (req, res) {
    var goal = req.body;
    Goal.create(goal, function (err, result) {
        if (err) {
            return res.status(500).send({message: 'create goal fail', error: err});
        }
        res.status(200).send(result);
    });
});

app.post('/goals/:id', function (req, res) {
    var params = req.params;

    var id = params.id;
    if (id) {
        var data = req.body;
        for (var i in data) {
            if (data[i] === 'null') {
                data[i] = null;
            }
        }
        Goal.findByIdAndUpdate(id, data, function (err, goal) {
            if (err) {
                Msg.error('update goal failed', err);
                return res.status(507).send({success: false, err: err});
            }
            res.status(200).send(goal);
        });
    }
});

app.delete('/goals/:id', function (req, res) {
    var params = req.params;
    var goalId = params.id;
    if (goalId) {
        Goal.findByIdAndRemove(goalId, function (err, result) {
            if (err) {
                Msg.error('delete goal failed', err);
                return res.status(500).send({success: false, err: err});
            }
            res.status(200).send(result);
        });
    }
});

var LogChecker = require('../logChecker');
app.get('/checkLogContent', function (req, res) {
    var query = req.query;
    if (query.start && query.end) {
        LogChecker.check(query.start, query.end).then(function (result) {
            res.status(200).send(result);
        }).catch(function (err) {
            res.status(500).send({success: false, error: err});
        });
    } else {
        res.status(500).send({success: false, error: 'need start and end params'});
    }
});

var defaulSettingsFilePath = path.resolve(__dirname, '../conf/defaultSettings.json');
var userSettingsFilePath = path.resolve(__dirname, '../conf/userSettings.json');


app.get('/settings', function (req, res) {
    var defaultSettings = JSON.parse(fs.readFileSync(defaulSettingsFilePath));
    var userSettings = JSON.parse(fs.readFileSync(userSettingsFilePath));
    res.status(200).send(_.extend(defaultSettings, userSettings));
});


app.post('/settings', function (req, res) {
    fs.writeFile(userSettingsFilePath, JSON.stringify(req.body,  null, 4), function (err) {
        if (err) {
            return res.status(500).send({success: false, error: err, message: 'change settings failed'});
        }
        //update config after write file success
        config.update();
        return res.status(200).send({success: true});
    });
});


app.get('/logContents/:date', function (req, res) {
    var date = req.params.date;
    if (!date) {
        return res.status(500).send({success: false, message: 'need date params like /logContents/2015-10-11'});
    }
    logFileHelper.readLogFiles(date).then(function (result) {
        res.status(200).send(result);
    }).catch(function (err) {
        return res.status(500).send({success: false, error: err, message: 'read log file failed'});
    });
});


app.post('/logContents/:date', function (req, res) {
    var date = req.params.date;
    var data = req.body;
    if (!date) {
        return res.status(500).send({success: false, message: 'need date params like /logContents/2015-10-11'});
    }
    logFileHelper.writeLogFile(date, data.content).then(function (result) {
        res.status(200).send({success: true});
    }).catch(function (err) {
        return res.status(500).send({success: false, error: err, message: 'write log file failed'});
    });
});



app.get('/classes', function (req, res) {
    LogClass.find(function (err, data) {
        res.status(200).send(data);
    });
});

function getLogAttr(params, type) {
    return logAttr.get(type, params);
}

function queryProjects(params) {
    return SearchProject.query(params);
}

function queryVersions(params) {
    return SearchVersion.query(params);
}


function queryTags(params) {
    return SearchTag.query(params);
}

function queryTasks(params) {
    return SearchTask.query(params);
}

function queryLogs(params) {
    return Search.query(params);
}

function backupNote(params) {
    return BackUp.backup(params);
}

function exportNote(params) {
    return Exporter.export(params);
}

function get(type, url, handler) {
    if (_.isFunction(url)) {
        handler = url;
        url = '/:year/:month?/:day?';
    } else if (url === null) {
        url = '';
    } else if (url === undefined){
        url = '/:year/:month?/:day?';
    }
    handler = handler || require('./components/' + type);
    app.get('/' + type + url, function(req, res) {
        var params = getCommonRequestParams(req.params, req.query);
        var promise;
        try {
            if (_.isFunction(handler)) {
                promise = handler(params, type);
            } else {
                promise = handler.generate(params);
            }
        } catch (e) {
            res.status(500).send({msg: 'Server Error', err: e.message});
        }
        promise.then(function(result) {
            res.status(200).send(result);
        }).catch(function(err) {
            console.error(err.stack || err);
            res.status(500).send({msg: 'Server Error', err: err.message});
        });
    });
}

exports.run = function(options) {
    var port = options.port || serverPort;
    return http.createServer(app).listen(port, function() {
        console.log("Server listening on port " + port);
    }).on('error', function (e) {
        if (e.code === 'EADDRINUSE') {
            Msg.error('Port ' +  port + ' is occupied');
            process.abort();
        }
    });
};


exports.start = function (options) {
    //return Q(1);
    var deferred = Q.defer();
    options = _.extend({port: serverPort}, options);
    if (!server) {
        server = http.createServer(app).listen(options.port, function() {
            console.log("Server listening on port " + options.port);
            deferred.resolve(server);
        }).on('error', function (e) {
            if (e.code === 'EADDRINUSE') {
                Msg.error('Port ' +  options.port + ' is occupied');
                deferred.reject(e);
            }
        });
    } else {
        return Q(server);
    }
    return deferred.promise;
};

exports.stop = function () {
    if (server) {
        server.close(function () {
            console.log('server closed');
        });
        server = null;
    }
};

exports.isRunning = function () {
    return !!server;
};


function getCommonRequestParams(params, query) {
    var dateStr = [
        params.year,
        params.month,
        params.day
    ].filter(function(val) {
        return !!val;
    }).join('-');
    preprocessQuery(query, ['projects', 'tags', 'classes', 'versions', 'tasks']);
    if (_.isString(query.populate)) {
        query.populate = (query.populate === 'true');
    }
    if (_.isString(query.aggregate)) {
        query.aggregate = (query.aggregate === 'true');
    }

    if (_.isString(query.calculateTimeConsume)) {
        query.calculateTimeConsume = (query.calculateTimeConsume === 'true');
    }
    var dateParams = {};
    if (dateStr) {
        dateParams = Param.getDateParams(dateStr);
    } else {
        if (query.start && query.end) {
            dateStr = [
                new Moment(query.start).format('YYYY-MM-DD'),
                new Moment(query.end).format('YYYY-MM-DD')
            ].join('~');
        }
        if (dateStr) {
            dateParams = Param.getDateParams(dateStr);
        }
    }

    return extend({}, _.pick(params, ['type', 'id']), dateParams, query);

    function preprocessQuery(query, attrs) {
        if (_.isEmpty(attrs)) {
            attrs = [];
        }
        Object.keys(query).forEach(function (key) {
            if (attrs.indexOf(key) >= 0) {
                var val = query[key],
                    arr = !val ? [] : val.split(',');
                query[key] = arr;
            }
        });
    }
}


function syncNote(params) {
    var options = params;
    return evernoteSync.sync(options);
}