'use strict';

var express = require('express');
var http = require('http');
var _ = require('lodash');
var Q = require('q');
var bodyParser = require('body-parser');
var multer = require('multer');
var app = express();

app.use(bodyParser.json()); // for parsing application/json
app.use(bodyParser.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded
app.use(multer()); // for parsing multipart/form-data

var execute = require('../execute');
var calandar = require('../calendar');
var extend = require('node.extend');
var stat  = require('./components/stat');
var Param = require('../param');
var logAttr = require('./components/logAttribute');
var Search = require('../search/search');
var SearchProject = require('../search/searchProject');
var Moment = require('moment');
var evernoteSync = require('../../tracker/sync/evernote');
var BackUp = require('../backup/backup');
var Exporter = require('../exporter');
var SearchTask = require('../search/searchTask');
var SearchVersion = require('../search/searchVersion');
var ClassesTrend = require('../statists/classTrend');

var Msg = require('../message');
var Task = require('../model/Task');
var Project = require('../model/project');
var Version = require('../model/version');
var Log = require('../model/log');


var server;

app.get('/actions/:actionName', function(req, res) {
    var actionName = req.params.actionName;
    execute.exec('ltt action ' + actionName + ' --cups 1');
    res.status(200).send('done');
});


app.get('/appInfo', function (req, res) {
    Q.spread([
        count(Project),
        count(Task),
        count(Log)
    ], function (pC, tC, lC) {
        res.status(200).send({
            projectCount: pC,
            taskCount: tC,
            logCount: lC
        });
    }).fail(function (err) {
        console.error(err.stack);
        res.status(500).send({success: false, err: err});
    });

    function count(Model) {
        var deferred = Q.defer();
        Model.count({}, function (err, count) {
            if (err) {
                return deferred.reject(err);
            }
            return deferred.resolve(count);
        });
        return deferred.promise;
    }
});

app.post('/tasks/:id', function (req, res) {
    var params = req.params;

    var taskId = params.id;
    if (taskId) {
        var data = _.pick(req.body, ['progress', 'name', 'description']);
        Task.findByIdAndUpdate(taskId, data, function (err, task) {
            if (err) {
                Msg.error('update task failed', err);
                res.status(507).send({success: false, err: err});
                return;
            }
            res.status(200).send(task);
        });
    }
});

app.delete('/projects/:id', function (req, res) {
    var params = req.params;
    var projectId = params.id;
    if (projectId) {
        Project.findByIdAndRemove(projectId, function (err, result) {
            if (err) {
                return res.status(500).send({success: false, err: err});
            }
            console.log(result);
            Q.spread([
                Version.remove({projectId: projectId}).exec(),
                Task.remove({projectId: projectId}).exec(),
            ], function (removeVersionCount, removeTaskCount) {
                res.status(200).send({
                    success: true,
                    removeTaskCount: removeTaskCount,
                    removeVersionCount: removeVersionCount
                });
            }).fail(function (err) {
                res.status(500).send({success: false, message: err.message, err: err});
            });
        });
    }
});

app.post('/backUpLogFile', function (req, res) {
    var body = req.body;
    evernoteSync.backUpLogFile(body.date, body.content).then(function () {
        res.status(200).send({success: true});
    }).fail(function (err) {
        res.status(507).send({success: false, err: err});
    });
});

get('calendars', '/:type', calandar);
get('stats', '/:year?/:month?/:day?', stat);
get('sleepPeriods', null);
get('classes', getLogAttr);
get('projects', '/:id?', queryProjects);
get('versions', '/:id?', queryVersions);
get('tasks', '/:id?', queryTasks);
get('tags', getLogAttr);
get('logs', '/:year?/:month?/:day?', queryLogs);
get('syncNote', null, syncNote);
get('backupNote', null, backupNote);
get('exportNote', null, exportNote);
get('classesTrend', null, function (params) {
    return ClassesTrend.query(params);
});


function getLogAttr(params, type) {
    return logAttr.get(type, params);
}

function queryProjects(params) {
    return SearchProject.query(params);
}

function queryVersions(params) {
    return SearchVersion.query(params);
}

function queryTasks(params) {
    return SearchTask.query(params);
}

function queryLogs(params) {
    return Search.query(params);
}

function backupNote(params) {
    return BackUp.backup(params);
}

function exportNote(params) {
    return Exporter.export(params);
}

function get(type, url, handler) {
    if (_.isFunction(url)) {
        handler = url;
        url = '/:year/:month?/:day?';
    } else if (url === null) {
        url = '';
    } else if (url === undefined){
        url = '/:year/:month?/:day?';
    }
    handler = handler || require('./components/' + type);
    app.get('/' + type + url, function(req, res) {
        var params = getCommonRequestParams(req.params, req.query);
        var promise;
        try {
            if (_.isFunction(handler)) {
                promise = handler(params, type);
            } else {
                promise = handler.generate(params);
            }
        } catch (e) {
            res.status(500).send({msg: 'Server Error', err: e.message});
        }
        promise.then(function(result) {
            res.status(200).send(result);
        }).catch(function(err) {
            console.error(err.stack || err);
            res.status(500).send({msg: 'Server Error', err: err.message});
        });
    });
}

exports.run = function(options) {
    var port = options.port || 3333;
    return http.createServer(app).listen(port, function() {
        console.log("Server listening on port " + port);
    }).on('error', function (e) {
        if (e.code === 'EADDRINUSE') {
            Msg.error('Port ' +  port + ' is occupied');
            process.abort();
        }
    });
};


exports.start = function (options) {
    var deferred = Q.defer();
    options = _.extend({port: 3333}, options);
    if (!server) {
        server = http.createServer(app).listen(options.port, function() {
            console.log("Server listening on port " + options.port);
            deferred.resolve(server);
        }).on('error', function (e) {
            if (e.code === 'EADDRINUSE') {
                Msg.error('Port ' +  options.port + ' is occupied');
                deferred.reject(e);
            }
        });
    } else {
        deferred.reject(new Error('Server already started'));
    }
    return deferred.promise;
};

exports.stop = function () {
    if (server) {
        server.close(function () {
            console.log('server closed');
        });
        server = null;
    }
};


function getCommonRequestParams(params, query) {
    var dateStr = [
        params.year,
        params.month,
        params.day
    ].filter(function(val) {
        return !!val;
    }).join('-');
    preprocessQuery(query, ['projects', 'tags', 'classes', 'versions', 'tasks']);
    if (_.isString(query.populate)) {
        query.populate = (query.populate === 'true');
    }
    if (_.isString(query.aggregate)) {
        query.aggregate = (query.aggregate === 'true');
    }

    if (_.isString(query.calculateTimeConsume)) {
        query.calculateTimeConsume = (query.calculateTimeConsume === 'true');
    }
    var dateParams = {};
    if (dateStr) {
        dateParams = Param.getDateParams(dateStr);
    } else {
        if (query.start && query.end) {
            dateStr = [
                new Moment(query.start).format('YYYY-MM-DD'),
                new Moment(query.end).format('YYYY-MM-DD')
            ].join('~');
        }
        if (dateStr) {
            dateParams = Param.getDateParams(dateStr);
        }
    }

    return extend({}, _.pick(params, ['type', 'id']), dateParams, query);

    function preprocessQuery(query, attrs) {
        if (_.isEmpty(attrs)) {
            attrs = [];
        }
        Object.keys(query).forEach(function (key) {
            if (attrs.indexOf(key) >= 0) {
                var val = query[key],
                    arr = !val ? [] : val.split(',');
                query[key] = arr;
            }
        });
    }
}


function syncNote(params) {
    var options = params;
    return evernoteSync.sync(options);
}