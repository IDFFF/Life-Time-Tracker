'use strict';

var _ = require('lodash');
var Q = require('q');
var TimeFormat = require('../timeFormat');
var dateTypeEnum = require('../enum/dateType');
var Moment = require('moment');
var Msg = require('../message');
var Project = require('../model/project');
var Task = require('../model/Task');
var Version = require('../model/version');
var mongoose = require('mongoose');
var ObjectId = mongoose.Types.ObjectId;
var extend = require('extend');

function getQueryConditions(options) {
    var $and = [], condition = {};
    syncOptions();
    if (!_.isEmpty($and)) {
        condition = {$and: $and};
    }
    return condition;

    function syncOptions() {
        //var dateCondition;
        /*if (options.dateItems) {
            dateCondition = getDateCondition(options);
        } else if (options.dateRange) {
            dateCondition = getDateRangeCondition(options);
        }
        if (dateCondition) {
            $and.push(dateCondition);
        }*/
        var filters = getFilters(options);
        if (!_.isEmpty(filters)) {
            $and = $and.concat(filters);
        }
    }
}

function getFilters(options) {
    var filters = [],
        classes = options.classes,
        peoples = options.peoples,
        tags = options.tags;
    if (!_.isEmpty(classes)) {
        filters.push(getArrayOperator('classes', classes));
    }

    var tagOperator = options.tagOperator || 'in';
    var peopleOperator = options.peopleOperator || 'in';
    if (!_.isEmpty(tags)) {
        if (tags.length === 1) {
            filters.push({
                tags: tags[0]
            });
        } else {
            var operator = {};
            operator[ tagOperator === 'all' ? '$all' : '$in'] = tags;
            filters.push({tags: operator});
        }
    }
    if (!_.isEmpty(peoples)) {
        if (peoples.length === 1) {
            filters.push({
                peoples: peoples[0]
            });
        } else {
            var peopleFilter = {};
            peopleFilter[ peopleOperator === 'all' ? '$all' : '$in'] = peoples;
            filters.push({peoples: peopleFilter});
        }
    }
    return filters;
}


function getDateRangeCondition(options) {
    var dateRange = options.dateRange;
    var from = dateRange.from,
        to = dateRange.to;
    var fromMoment = getMoment(from, true, false),
        toMoment = getMoment(to, false, true);
    if (toMoment.diff(fromMoment, 'days') < 0) {
        var error = 'Wrong date range';
        Msg.error(error);
        throw new Error(error);
    } else {
        return {
            date: {
                $gte: new Date(fromMoment.format(TimeFormat.fullTime)),
                $lt: new Date(toMoment.format(TimeFormat.fullTime))
            }
        };
    }
}

function getDateCondition(options) {
    var condition,
        date = options.dateItems[0];
    if (date) {
        if (date.type === dateTypeEnum.Day) {
            condition = new Date(date.value);
        } else if (date.type === dateTypeEnum.Month) {
            condition = to$Operator(date, 'month');
        } else if (date.type === dateTypeEnum.Year) {
            condition = to$Operator(date, 'year');
        }
    }
    function to$Operator(date, dateType) {
        var m = new Moment(date.value);
        var startDate = m.startOf(dateType).format(TimeFormat.date),
            endDate = m.endOf(dateType).format(TimeFormat.date);
        return {
            $gte: new Date(startDate),
            $lt: new Date(endDate)
        };
    }

    return {
        date: condition
    };
}


function getArrayOperator(name, arr, identity) {
    var operator = {}, $elemMatch;
    if (arr.length === 1) {
        if (identity) {
            $elemMatch = {};
            $elemMatch[identity] = arr[0];
            operator[name] = {
                $elemMatch: $elemMatch
            };
        } else {
            operator[name] = arr[0];
        }
    } else {
        if (identity) {
            $elemMatch = {};
            $elemMatch[identity] = { $in: arr };
            operator[name] = {
                $elemMatch: $elemMatch
            };
        } else {
            operator[name] = { $in: arr };
        }
    }
    return operator;
}



function getMoment(dateObj, isStart, isEnd) {
    var dateType = dateObj.type,
        dateValue = dateObj.value,
        m;
    var operator;
    if (isStart) { operator = 'startOf'; }
    if (isEnd) { operator = 'endOf'; }
    if (dateType === dateTypeEnum.Day) {
        m = new Moment(dateValue)[operator]('day');
    } else if (dateType === dateTypeEnum.Month) {
        m = new Moment(dateValue)[operator]('month');
    } else if (dateType === dateTypeEnum.Year) {
        m = new Moment(dateValue)[operator]('year');
    }
    return m;
}


exports.getQueryConditions = getQueryConditions;
exports.getSortParams = function (sortStr) {
    if (!sortStr) {
        return;
    }
    sortStr = sortStr.trim();
    var sortArray = sortStr.split(',');
    var result = {};
    sortArray.forEach(function (sort) {
        sort = sort.trim();
        var keyValue = sort.split(':');
        result[keyValue[0]] = parseInt(keyValue[1], 10);
    });
    return result;
};


exports.getGroupParams = function (groupStr) {
    /** 参考
    {
        $group : {
           _id : { month: { $month: "$date" }, day: { $dayOfMonth: "$date" }, year: { $year: "$date" } },
           totalPrice: { $sum: { $multiply: [ "$price", "$quantity" ] } },
           averageQuantity: { $avg: "$quantity" },
           count: { $sum: 1 }
        }
     */
    if (!groupStr) {
        return;
    }
    var groupArr = groupStr.split(/\+|\s+/);
    var result = {};
    var onlyOneGroup = (groupArr.length === 1);
    groupArr.forEach(function (grp) {
        var isDate = (grp.indexOf('date') === 0);
        if (onlyOneGroup && !isDate) {
            result = '$' + grp;
        } else if (onlyOneGroup && isDate) {
            result = toDate(grp);
        } else if (!onlyOneGroup && isDate) {
            if (grp.indexOf('.') > 0) {
                var field = grp.split('.')[0];
                result[field] = toDate(grp);
            } else {
                result[grp] = toDate(grp);
            }
        } else if (!onlyOneGroup && !isDate) {
            result[grp] = '$' + grp;
        }
    });
    return result;

    function toDate (group) {
        var result;
        if (group.indexOf('.') > 0) {
            var tmpArr = group.split('.');
            var dateType = tmpArr[1].toLowerCase();
            if (dateType === 'year') {
                result = {$dateToString: { format: "%Y", date: "$date" }};
            } else if (dateType === 'month') {
                result = { $dateToString: { format: "%Y-%m", date: "$date" }};
            } else if (dateType === 'day') {
                result = { $dateToString: { format: "%Y-%m-%d", date: "$date" }};
            } else if (dateType === 'week') {
                result = { $week: '$date'};
            }
        } else {
            result = '$' + group;
        }
        return result;
    }
};

function getProjectIds(projects, suffix) {
    return getIds('project', Project, [{
        value: projects,
        identity: 'name'
    }], suffix);
}


function getTaskIds(tasks, suffix) {
    return getIds('task', Task, [{
        value: tasks,
        identity: 'name'
    }], suffix);
}

function getVersionIds(versions, suffix) {
    return getIds('version', Version, [{
        value: versions,
        identity: 'name'
    }], suffix);
}


function getIds(typeName, model, userQuerys, suffix) {
    var deferred = Q.defer();
    var empty = _.isEmpty(userQuerys) || userQuerys.filter(function(userQuery) {
        return !_.isEmpty(userQuery.value);
    }).length === 0;
    if (empty) {
        deferred.resolve(null);
        return;
    }
    var condition = {};
    userQuerys.forEach(function(userQuery) {
        var query = userQuery.value;
        if (!_.isEmpty(query)) {
            _.extend(condition, _CD(query, userQuery.identity));
        }
    });
    model.find(condition, function(err, items) {
        var idCondition;
        if (err) {
            Msg.error('Error occur when search with items' + JSON.stringify(condition), err);
            deferred.reject(err);
            return;
        }
        var ids = null;
        if (!_.isEmpty(items)) {
            ids = items.map(getId);
            getSubId(ids).then(function(subIds) {
                ids = ids.concat(subIds);
                idCondition = _CD(ids, typeName, suffix);
                deferred.resolve(idCondition);
            });
        } else {
            deferred.resolve(null);
        }
    });

    function getId(item) {
        return item ? new ObjectId(item.id) : null;
    }

    function getSubId(parentId) {
        var deferred = Q.defer();

        model.find(_CD(parentId, 'parent'), function(err, result) {
            if (err) {
                throw err;
            }
            deferred.resolve(result.map(getId));
        });
        return deferred.promise;
    }
    return deferred.promise;
}

function _CD(items, name, suffix) {
    if (!_.isArray(items)) {
        items = [items];
    }
    if (suffix) {
        name = name + suffix;
    }
    var condition = {};
    var length = items.length;
    if (length === 1) {
        condition[name] = items[0];
    } else if (length > 1) {
        condition[name] = {
            $in: items
        };
    }
    return condition;
}

function getChildTasks(taskId) {
    var deferred = Q.defer();
    var descendants = [];
    Task.findById(taskId, function (err, task) {
        if (err) {
            return deferred.reject(err);
        }
        if (!task) {
            return deferred.resolve(descendants);
        }
        var children = task.get('children');
        if(!_.isEmpty(children)) {
            descendants = descendants.concat(children);
            Q.allSettled(children.map(function (taskId) {
                return getChildTasks(taskId).then(function (subTasks) {
                    descendants = descendants.concat(subTasks);
                    deferred.resolve(descendants);
                });
            }));
        } else {
            deferred.resolve(descendants);
        }
    });
    return deferred.promise;
}



exports.getIds = function (options, suffix) {
    console.log(suffix);
    return Q.allSettled([
        getProjectIds(options.projects, suffix),
        getTaskIds(options.tasks, suffix),
        getVersionIds(options.versions, suffix)
    ]).then(function(idsConditions) {
        idsConditions = _.compact(_.pluck(idsConditions, 'value'));
        if (options.projectId) {
            idsConditions.push(_CD(options.projectId, 'project', suffix));
        }

        if (options.versionId) {
            idsConditions.push(_CD(options.versionId, 'version', suffix));
        }
        return idsConditions;
    }).then(function (idsConditions) {
        if (options.taskId) {
            return getChildTasks(options.taskId).then(function (taskIds) {
                if (options.taskId) {
                    taskIds.push(new ObjectId(options.taskId));
                }
                idsConditions.push(_CD(taskIds, 'task', suffix));
                return idsConditions;
            });
        }
        return idsConditions;
    });
};


exports.preprocessQuery = function preprocessQuery(query, attrs) {
    if (_.isEmpty(attrs)) {
        attrs = [];
    }
    Object.keys(query).forEach(function (key) {
        if (attrs.indexOf(key) >= 0 && _.isString(query[key])) {
            var val = query[key],
                arr = !val ? [] : val.split(',');
            query[key] = arr;
        }
    });
};