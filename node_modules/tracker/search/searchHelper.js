var _ = require('lodash');
var TimeFormat = require('../timeFormat');
var dateTypeEnum = require('../enum/dateType');
var Moment = require('moment');
var Msg = require('../message');

function getQueryConditions(options) {
    var $and = [], condition = {};
    syncOptions();
    if (!_.isEmpty($and)) {
        condition = {$and: $and};
    }
    return condition;

    function syncOptions() {
        var dateCondition;
        if (options.dateItems) {
            dateCondition = getDateCondition(options);
        } else if (options.dateRange) {
            dateCondition = getDateRangeCondition(options);
        }
        if (dateCondition) {
            $and.push(dateCondition);
        }
        var filters = getFilters(options);
        if (!_.isEmpty(filters)) {
            $and = $and.concat(filters);
        }
    }
}

function getFilters(options) {
    var filters = [],
        classes = options.classes,
        tags = options.tags;
    if (!_.isEmpty(classes)) {
        filters.push(getArrayOperator('classes', classes, 'code'));
    }

    if (!_.isEmpty(tags)) {
        if (tags.length === 1) {
            filters.push({
                tags: tags[0]
            });
        } else {
            filters.push({
                tags: {
                    $in: tags
                }
            });
        }
    }
    return filters;
}


function getDateRangeCondition(options) {
    var dateRange = options.dateRange;
    var from = dateRange.from,
        to = dateRange.to;
    var fromMoment = getMoment(from, true, false),
        toMoment = getMoment(to, false, true);
    if (toMoment.diff(fromMoment, 'days') < 0) {
        var error = 'Wrong date range';
        Msg.error(error);
        throw new Error(error);
    } else {
        return {
            date: {
                $gte: new Date(fromMoment.format(TimeFormat.fullTime)),
                $lt: new Date(toMoment.format(TimeFormat.fullTime))
            }
        };
    }
}

function getDateCondition(options) {
    var condition,
        date = options.dateItems[0];
    if (date) {
        if (date.type === dateTypeEnum.Day) {
            condition = new Date(date.value);
        } else if (date.type === dateTypeEnum.Month) {
            condition = to$Operator(date, 'month');
        } else if (date.type === dateTypeEnum.Year) {
            condition = to$Operator(date, 'year');
        }
    }
    function to$Operator(date, dateType) {
        var m = new Moment(date.value);
        var startDate = m.startOf(dateType).format(TimeFormat.date),
            endDate = m.endOf(dateType).format(TimeFormat.date);
        return {
            $gte: new Date(startDate),
            $lt: new Date(endDate)
        };
    }

    return {
        date: condition
    };
}


function getArrayOperator(name, arr, identity) {
    var operator = {},
        $elemMatch = {};
    if (arr.length === 1) {
        $elemMatch[identity] = arr[0];
        operator[name] = {
            $elemMatch: $elemMatch
        };
    } else {
        $elemMatch[identity] = { $in: arr };
        operator[name] = {
            $elemMatch: $elemMatch
        };
    }
    return operator;
}



function getMoment(dateObj, isStart, isEnd) {
    var dateType = dateObj.type,
        dateValue = dateObj.value,
        m;
    var operator;
    if (isStart) { operator = 'startOf'; }
    if (isEnd) { operator = 'endOf'; }
    if (dateType === dateTypeEnum.Day) {
        m = new Moment(dateValue)[operator]('day');
    } else if (dateType === dateTypeEnum.Month) {
        m = new Moment(dateValue)[operator]('month');
    } else if (dateType === dateTypeEnum.Year) {
        m = new Moment(dateValue)[operator]('year');
    }
    return m;
}


exports.getQueryConditions = getQueryConditions;