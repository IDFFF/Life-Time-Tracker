var Q = require('q');
var _ = require('lodash');
var Moment = require('moment');
var ObjectId = require('mongoose').Types.ObjectId;

//models
var Task = require('../model/Task');
var Log = require('../model/log');


exports.query = function (options) {
    options = _.extend({ populate: true }, options);
    if (options.id) {
        return queryTaskById(options);
    } else {
        return queryTasksByConditions(options);
    }
};


function queryTasksByConditions(options) {
    var deferred = Q.defer();
    var conditions = getQueryConditions(options);
    var queryOptions = getQueryOptions(options);

    function calculateTaskTimeConsume(task) {
        var deferred = Q.defer();
        Log.aggregate()
            .match({task: new ObjectId(task._id)})
            .group({_id: '$task', totalTime: {$sum: "$len"}})
            .exec()
            .then(function (result) {
                var calculteResult = result[0],
                    totalTime = 0;
                if (!calculteResult) {
                    totalTime = 0;
                } else {
                    totalTime = calculteResult.totalTime;
                }
                //if have children, then calculate the children's time consume
                if (task.children.length > 0) {
                    Q.allSettled(task.children.map(calculateTaskTimeConsume)).then(function (results) {
                        totalTime = results.reduce(function (totalTime, result) {
                            if (result.state === "fulfilled") {
                                totalTime += result.value;
                            }
                            return totalTime;
                        }, totalTime);
                        task.totalTime = totalTime;
                        deferred.resolve();
                    });
                } else {
                    task.totalTime = totalTime;
                    deferred.resolve(totalTime);
                }
            }).on('reject', function (err) {
                deferred.reject(err);
            });
        return deferred.promise;
    }
    // var query = Task.find(conditions, null, queryOptions);
    console.log(JSON.stringify(conditions), JSON.stringify(queryOptions));
    // if (options.populate) {
    //     query = query.populate([{
    //         path: 'children'
    //     }]);
    // }
    // var taskStatus = options.status;
    // var isMarked = (options.marked === 'true' || options.marked === true);
    // var withoutParent = (options.parent === undefined);
    if (options.parent) {
        Task.find(conditions, null, queryOptions, function (err, tasks) {
            //calculate total time consume for each task
            if (options.calculateTimeConsume) {
                Q.allSettled(tasks.map(calculateTaskTimeConsume)).then(function () {
                    deferred.resolve(tasks);
                }).catch(function (err) {
                    deferred.reject(err);
                });
            } else {
                deferred.resolve(tasks);
            }
        });
        return deferred.promise;
    }

    Task.aggregate([{
        $match: conditions
    }, {
        $sort: {lastActiveTime: -1}
    }]).group({
        _id: '$parent',
        items: {$push: "$$ROOT"}
    }).exec(function (err, lists) {
        var tasks = [];
        //return deferred.resolve(lists);
        console.log(lists);
        if (err) {
            return deferred.reject(err);
        }
        var parentIndex, parentList;
        lists.some(function (list, index) {
            if (list._id === null) {
                parentIndex = index;
                return true;
            }
            return false;
        });
        if (parentIndex !== undefined) {
            parentList = lists.splice(parentIndex, 1)[0];
        }
        if (parentList) {
            parentList.items.forEach(function (parentItem, parentIndex) {
                var parentId = parentItem._id.toString();
                var matchIndex;
                lists.some(function (list, index) {
                    var listId = list._id;
                    if (listId !== null) {
                        listId = listId.toString();
                    }
                    if (listId === parentId) {
                        matchIndex = index;
                        return true;
                    }
                    return false;
                });
                if (matchIndex !== undefined) {
                    parentItem.children = lists.splice(matchIndex, 1)[0].items;
                } else {
                    parentItem.children = [];
                }
            });
            tasks = parentList.items;
        }
        tasks = lists.reduce(function (result, list) {
            return result.concat(list.items);
        }, tasks).filter(function (task) {
            if (options.status === 'done' && task.progress > 0 && task.progress < 100 && _.isEmpty(task.children)) {
                return false;
            } else {
                return true;
            }
        });
        //calculate total time consume for each task
        if (options.calculateTimeConsume) {
            Q.allSettled(tasks.map(calculateTaskTimeConsume)).then(function () {
                deferred.resolve(tasks);
            }).catch(function (err) {
                deferred.reject(err);
            });
        } else {
            deferred.resolve(tasks);
        }

        
        // if (_.isEmpty(tasks)) {
        //     return deferred.resolve([]);
        // }
        // tasks.forEach(function (task) {
        //     task.children = task.children.filter(function (childTask) {
        //         var bool = true;
        //         if (isMarked) {
        //             bool = bool && childTask.marked === true;
        //         }
        //         if (taskStatus === 'doing') {
        //             return  bool && childTask.progress > 0 && childTask.progress < 100;
        //         } else if (taskStatus === 'done') {
        //             return  bool && childTask.progress === 100;
        //         } else {
        //             return bool && true;
        //         }
        //     }).sort(function (a, b) {
        //         return new Date(b.lastActiveTime).getTime() - new Date(a.lastActiveTime).getTime();
        //     });
        // });

        // if (withoutParent) {
        //     console.log(tasks.length);
        //     tasks = tasks.filter(function (task) {
        //         var parent = task.parent;
        //         //task is not a subtask of the task in the `tasks`
        //         var result  = !parent || !tasks.some(function (task) {
        //             return task._id.toString() === parent.toString();
        //         });
        //         return result;
        //     });
        //     console.log(tasks.length);
        // }
    });

    return deferred.promise;
}

function queryTaskById(id) {

}


function getQueryConditions(options) {
    var parentCondition;
    var tags = options.tags;
    if (options.parent === null || options.parent === 'null') {
        parentCondition =  {parent: { $type: 10 }};
    } else if (options.parent) {
        parentCondition = {parent: options.parent};
    }
    var conditions = [],
        timeCondition = [];
    if (parentCondition) {
        conditions.push(parentCondition);
    }
    if (options.start && options.end) {
        timeCondition.push({
            createTime: {
                $gt: new Moment(options.start).startOf('day').toDate(),
                $lt: new Moment(options.end).endOf('day').toDate()
            }
        });

        timeCondition.push({
            lastActiveTime: {
                $gt: new Moment(options.start).startOf('day').toDate(),
                $lt: new Moment(options.end).endOf('day').toDate()
            }
        });

        timeCondition.push({
            $and: [{
                lastActiveTime: { $gte: new Moment(options.end).endOf('day').toDate() }
            }, {
                createTime: {$lte: new Moment(options.start).startOf('day').toDate() }
            }]
        });
    }
    var taskStatus = options.status;
    if (taskStatus === 'doing') {
        conditions.push({
            $or: [
                {progress: {$gte: 0, $lt: 100}}, //doing
                {progress: -1, children : {$not: {$size: 0}}} //have no progress but have children
            ]
        });
    } else if (taskStatus === 'done'){
        conditions.push({
            $or: [{
                progress: 100
            }, {
                progress: {$lt: 100},
                children : {$not: {$size: 0}}
            }]
        });
    }
    if (options.projectId) {
        conditions.push({
            projectId: new ObjectId(options.projectId)
        });
    }

    if (options.versionId) {
        conditions.push({
            versionId: new ObjectId(options.versionId)
        });
    }

    var isMarked = (options.marked === 'true' || options.marked === true);

    if (isMarked) {
        conditions.push({
            marked: isMarked
        });
    }

    if (options.name) {
        conditions.push({
            name: options.name
        });
    }

    if (!_.isEmpty(timeCondition)) {
        conditions.push({
            $or: timeCondition
        });
    }


    if (options.dueDays) {
        var dueDays = parseInt(options.dueDays, 10);
        //var now = new Moment();
        //console.log(dueDays, new Moment().add(dueDays, 'days').format('YYYY-MM-DD'));
        conditions.push({
            dueTime: {
                "$gt": new Moment().toDate(),
                "$lte": new Moment().add(dueDays, 'days').toDate()
            }
        });
    }
    if (options.overDue === 'true') {
        conditions.push({
            dueTime: {
                "$lt": new Moment().toDate()
            }
        });
    }

    if (options.notActiveDay) {
        var notActiveDay = parseInt(options.notActiveDay, 10);
        conditions.push({
            lastActiveTime: {
                "$lte": new Moment().subtract(notActiveDay, 'day').toDate()
            }
        });
    }

    if (!_.isEmpty(tags)) {
        conditions.push({
            tags: {
                $in: tags
            }
        });
    }

    if (!_.isEmpty(conditions)) {
        console.log(conditions);
        return {
            $and: conditions
        };
    }

    return null;
}

function getQueryOptions(userOptions) {
    var queryOptions = _.pick(userOptions, ['limit', 'skip']);
    //默认按照最后活动时间倒序排列
    queryOptions.sort = {lastActiveTime: -1};
    return queryOptions;
}
