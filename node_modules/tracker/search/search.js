/**
 * search logs
 *
 */

'use strict';


var Q = require('q');
var Log = require('../model/log');
var _ = require('lodash');
var Project = require('../model/project');
var Task = require('../model/Task');
var Version = require('../model/version');
var Msg = require('../message');
var mongoose = require('mongoose');
var ObjectId = mongoose.Types.ObjectId;
var Promise = mongoose.Promise;

var searchHelper = require('./searchHelper');


var NOT_EMPTY = function(val) {
    return !!val;
};

exports.query = function(options) {
    var deferred = Q.defer();
    options = _.extend({
        populate: true
    }, options);
    queryLog(options, function(result) {
        if (_.isArray(result)) {
            result = result.map(function(item) {
                if (item.toJSON) {
                    return item.toJSON();
                }
                return item;
            });
        }
        deferred.resolve(result);
    }, function(err) {
        deferred.reject(err);
    });
    return deferred.promise;
};

function getOperator(str) {
    var operators = { '>' : '$gt', '<': '$lt', '>=': '$gte', '<=': '$lte'};
    return operators[str];
}

function queryLog(options, onSuccess, onError) {
    var conditions = searchHelper.getQueryConditions(options);

    if (options.len) {
        console.log(options.len);
        var lenConditions = options.len.split('AND');
        var condition = {};
        lenConditions.forEach(function (lenCondition) {
            var numStr = lenCondition.match(/\d+/, ''),
                operatorStr = lenCondition.replace(/\d+/, ''),
                num;
            if (numStr) {
                num = parseInt(numStr, 10);
                if (!operatorStr) {
                    condition = num;
                } else if (operatorStr !== '=') {
                    condition[getOperator(operatorStr)] = num;
                } else {
                    condition = num;
                }
                console.log(condition);
            }
        });
        conditions.$and.push({
            len: condition
        });
    }
    console.log(conditions);
    var hasMatchIds = function(idConditions, userFilters) {
        if (_.isEmpty(idConditions)) {
            return false;
        }
        return userFilters.reduce(function(result, filterName) {
            return result && idConditions.filter(function(condition) {
                return !_.isEmpty(condition[filterName]);
            }).length > 0;
        }, true);
    };
    Q.allSettled([
        getProjectIds(options.projects),
        getTaskIds(options.tasks),
        getVersionIds(options.versions)
    ]).then(function(idsConditions) {
        idsConditions = _.compact(_.pluck(idsConditions, 'value'));
        if (options.projectId) {
            idsConditions.push(_CD(options.projectId, 'project'));
        }

        if (options.versionId) {
            idsConditions.push(_CD(options.versionId, 'version'));
        }
        return idsConditions;
    }).then(function (idsConditions) {
        if (options.taskId) {
            return getChildTasks(options.taskId).then(function (taskIds) {
                if (options.taskId) {
                    taskIds.push(new ObjectId(options.taskId));
                }
                idsConditions.push(_CD(taskIds, 'task'));
                return idsConditions;
            });
        }
        return idsConditions;
    }).then(function (idsConditions) {
        var userFilters = ['project', 'task', 'version'].filter(function(filterName) {
            return options[filterName + 's']; //append 's' because options is plural, like projects;
        });
        //if can't find any suit ids, then no need for logs query
        //return empty array immediately
        if (!_.isEmpty(userFilters) && !hasMatchIds(idsConditions, userFilters)) {
            onSuccess([]);
            return;
        }
        var queryOptions = getQueryOptions(options);
        conditions.$and = (conditions.$and || []).concat(idsConditions);
        if (_.isEmpty(conditions.$and)) {
            conditions = {};
        }
        var args = [
            conditions,
            options.fields || null,
            queryOptions
        ];
        var sortOption = _.extend({start: 1}, searchHelper.getSortParams(options.sort));
        var groupOption = searchHelper.getGroupParams(options.group);
        if (!options.sum) {
            var promise = Log.find.apply(Log, args);
            if (options.populate) {
                promise = promise.populate([{
                    path: 'project'
                }, {
                    path: 'task'
                }, {
                    path: 'version'
                }]);
            }
            promise.sort(sortOption)
                .exec(function(err, logs) {
                    if (err) {
                        onError(err);
                        return;
                    }
                    //populate sub task
                    var tasks = logs.map(function(log) {
                        return log.task;
                    }).filter(NOT_EMPTY);
                    var promise = Task.populate(tasks, 'parent');
                    promise.then(function() {
                        onSuccess(logs);
                    }).end();
                });
        } else {
            var aggregate = Log.aggregate({
                $match: conditions
            }).sort(sortOption);

            if (options.group && options.group.indexOf('classes') >= 0) {
               aggregate = aggregate.unwind("classes");
            }

            if (options.group && options.group.indexOf('tags') >= 0) {
               aggregate = aggregate.unwind("tags");
            }


            if (options.sum) {
                aggregate.group({
                    _id: groupOption || null,
                    totalTime: {$sum: '$len'}
                });
            } else {
                aggregate.group({
                    _id: groupOption,
                    logs: { $push: "$$ROOT" }
                });
            }
            var map = {
                project: Project,
                task: Task,
                version: Version
            };
            aggregate.exec(function (err, result) {
                if (err) {
                    return onError(err);
                }
                function populate (group) {
                    var promise;
                    var singleGroup = (group.split(' ').length === 1);
                    function wrap(p) {
                        if (promise) {
                            promise = promise.then(function () {
                                return p;
                            });
                        } else {
                            promise = p;
                        }
                    }
                    if (singleGroup) {
                        var model = map[group];
                        var select = 'name';
                        if (model) {
                            if (group === 'task') {
                                select += ' parent';
                            }
                            return model.populate(result, [{path: '_id', select: select}]);
                        }
                    } else {
                        if (group.indexOf('project') >= 0) {
                            wrap(Project.populate(result, [{path: '_id.project', select: 'name'}]));
                        }

                        if (group.indexOf('version') >= 0) {
                            wrap(Version.populate(result, [{path: '_id.version', select: 'name'}]));
                        }

                        if (group.indexOf('task') >= 0) {
                            wrap(Task.populate(result, [{path: '_id.task', select: 'name parent'}]));
                        }
                    }
                    return promise;
                }
                if (options.group) {
                    var tmpArr = options.group.split(' ');
                    var noPopulate = tmpArr.length === 1 && tmpArr[0].indexOf('date') === 0;
                    if (options.populate && !noPopulate && map[options.group]) {
                        populate(options.group).then(function (result) {
                            onSuccess(result);
                        });
                    } else {
                        onSuccess(result);
                    }
                } else {
                    onSuccess(result);
                }
                
            });
        }
    });
}

function getChildTasks(taskId) {
    var deferred = Q.defer();
    var descendants = [];
    Task.findById(taskId, function (err, task) {
        if (err) {
            return deferred.reject(err);
        }
        if (!task) {
            return deferred.resolve(descendants);
        }
        var children = task.get('children');
        if(!_.isEmpty(children)) {
            descendants = descendants.concat(children);
            Q.allSettled(children.map(function (taskId) {
                return getChildTasks(taskId).then(function (subTasks) {
                    descendants = descendants.concat(subTasks);
                    deferred.resolve(descendants);
                });
            }));
        } else {
            deferred.resolve(descendants);
        }
    });
    return deferred.promise;
}



function getQueryOptions(usrOptions) {
    var queryOptions = _.pick(usrOptions, ['limit', 'skip']);
    return queryOptions;
}



function getProjectIds(projects) {
    return getIds('project', Project, [{
        value: projects,
        identity: 'name'
    }]);
}


function getTaskIds(tasks) {
    return getIds('task', Task, [{
        value: tasks,
        identity: 'name'
    }]);
}

function getVersionIds(versions) {
    return getIds('version', Version, [{
        value: versions,
        identity: 'name'
    }]);
}


function getIds(typeName, model, userQuerys) {
    var deferred = Q.defer();
    var empty = _.isEmpty(userQuerys) || userQuerys.filter(function(userQuery) {
        return !_.isEmpty(userQuery.value);
    }).length === 0;
    if (empty) {
        deferred.resolve(null);
        return;
    }
    var condition = {};
    userQuerys.forEach(function(userQuery) {
        var query = userQuery.value;
        if (!_.isEmpty(query)) {
            _.extend(condition, _CD(query, userQuery.identity));
        }
    });
    model.find(condition, function(err, items) {
        var idCondition;
        if (err) {
            Msg.error('Error occur when search with items' + JSON.stringify(condition), err);
            deferred.reject(err);
            return;
        }
        var ids = null;
        if (!_.isEmpty(items)) {
            ids = items.map(getId);
            getSubId(ids).then(function(subIds) {
                ids = ids.concat(subIds);
                idCondition = _CD(ids, typeName);
                deferred.resolve(idCondition);
            });
        } else {
            deferred.resolve(null);
        }
    });

    function getId(item) {
        return item ? new ObjectId(item.id) : null;
    }

    function getSubId(parentId) {
        var deferred = Q.defer();

        model.find(_CD(parentId, 'parent'), function(err, result) {
            if (err) {
                throw err;
            }
            deferred.resolve(result.map(getId));
        });
        return deferred.promise;
    }
    return deferred.promise;
}

function _CD(items, name) {
    if (!_.isArray(items)) {
        items = [items];
    }
    var condition = {};
    var length = items.length;
    if (length === 1) {
        condition[name] = items[0];
    } else if (length > 1) {
        condition[name] = {
            $in: items
        };
    }
    return condition;
}