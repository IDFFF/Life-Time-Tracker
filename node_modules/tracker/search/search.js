/**
 * search logs
 *
 */

'use strict';


var Q = require('q');
var Log = require('../model/log');
var _ = require('lodash');
var Project = require('../model/project');
var Task = require('../model/Task');
var Version = require('../model/version');
var Msg = require('../message');
var ObjectId = require('mongoose').Types.ObjectId;

var searchHelper = require('./searchHelper');


var NOT_EMPTY = function(val) {
    return !!val;
};

exports.query = function(options) {
    var deferred = Q.defer();
    options = _.extend({
        populate: true
    }, options);
    queryLog(options, function(result) {
        deferred.resolve(result.map(function(item) {
            return item.toJSON();
        }));
    }, function(err) {
        deferred.reject(err);
    });
    return deferred.promise;
};


function queryLog(options, onSuccess, onError) {
    var conditions = searchHelper.getQueryConditions(options);
    var hasMatchIds = function(idConditions, userFilters) {
        if (_.isEmpty(idConditions)) {
            return false;
        }
        return userFilters.reduce(function(result, filterName) {
            return result && idConditions.filter(function(condition) {
                return !_.isEmpty(condition[filterName]);
            }).length > 0;
        }, true);
    };
    Q.allSettled([
        getProjectIds(options.projects),
        getTaskIds(options.tasks),
        getVersionIds(options.versions)
    ]).then(function(idsConditions) {
        idsConditions = _.compact(_.pluck(idsConditions, 'value'));
        if (options.projectId) {
            idsConditions.push(_CD(options.projectId, 'project'));
        }

        if (options.versionId) {
            idsConditions.push(_CD(options.versionId, 'version'));
        }
        return idsConditions;
    }).then(function (idsConditions) {
        if (options.taskId) {
            return getChildTasks(options.taskId).then(function (taskIds) {
                if (options.taskId) {
                    taskIds.push(new ObjectId(options.taskId));
                }
                idsConditions.push(_CD(taskIds, 'task'));
                return idsConditions;
            });
        }
        return idsConditions;
    }).then(function (idsConditions) {
        var userFilters = ['project', 'task', 'version'].filter(function(filterName) {
            return options[filterName + 's']; //append 's' because options is plural, like projects;
        });
        //if can't find any suit ids, then no need for logs query
        //return empty array immediately
        if (!_.isEmpty(userFilters) && !hasMatchIds(idsConditions, userFilters)) {
            onSuccess([]);
            return;
        }
        var queryOptions = getQueryOptions(options);
        conditions.$and = (conditions.$and || []).concat(idsConditions);
        var args = [
            conditions,
            options.fields || null,
            queryOptions
        ];
        var promise = Log.find.apply(Log, args);
        if (options.populate) {
            promise = promise.populate([{
                path: 'project'
            }, {
                path: 'task'
            }, {
                path: 'version'
            }]);
        }
        var sortOption = _.extend({start: 1}, searchHelper.getSortParams(options.sort));
        promise.sort(sortOption)
            .exec(function(err, logs) {
                if (err) {
                    onError(err);
                    return;
                }
                //populate sub task
                var tasks = logs.map(function(log) {
                    return log.task;
                }).filter(NOT_EMPTY);
                var promise = Task.populate(tasks, 'parent');
                promise.then(function() {
                    onSuccess(logs);
                }).end();
            });
    });
}

function getChildTasks(taskId) {
    var deferred = Q.defer();
    var descendants = [];
    Task.findById(taskId, function (err, task) {
        if (err) {
            return deferred.reject(err);
        }
        var children = task.get('children');
        if(!_.isEmpty(children)) {
            descendants = descendants.concat(children);
            Q.allSettled(children.map(function (taskId) {
                return getChildTasks(taskId).then(function (subTasks) {
                    descendants = descendants.concat(subTasks);
                    deferred.resolve(descendants);
                });
            }));
        } else {
            deferred.resolve(descendants);
        }
    });
    return deferred.promise;
}



function getQueryOptions(usrOptions) {
    var queryOptions = _.pick(usrOptions, ['limit', 'skip']);
    return queryOptions;
}



function getProjectIds(projects) {
    return getIds('project', Project, [{
        value: projects,
        identity: 'name'
    }]);
}


function getTaskIds(tasks) {
    return getIds('task', Task, [{
        value: tasks,
        identity: 'name'
    }]);
}

function getVersionIds(versions) {
    return getIds('version', Version, [{
        value: versions,
        identity: 'name'
    }]);
}


function getIds(typeName, model, userQuerys) {
    var deferred = Q.defer();
    var empty = _.isEmpty(userQuerys) || userQuerys.filter(function(userQuery) {
        return !_.isEmpty(userQuery.value);
    }).length === 0;
    if (empty) {
        deferred.resolve(null);
        return;
    }
    var condition = {};
    userQuerys.forEach(function(userQuery) {
        var query = userQuery.value;
        if (!_.isEmpty(query)) {
            _.extend(condition, _CD(query, userQuery.identity));
        }
    });
    model.find(condition, function(err, items) {
        var idCondition;
        if (err) {
            Msg.error('Error occur when search with items' + JSON.stringify(condition), err);
            deferred.reject(err);
            return;
        }
        var ids = null;
        if (!_.isEmpty(items)) {
            ids = items.map(getId);
            getSubId(ids).then(function(subIds) {
                ids = ids.concat(subIds);
                idCondition = _CD(ids, typeName);
                deferred.resolve(idCondition);
            });
        } else {
            deferred.resolve(null);
        }
    });

    function getId(item) {
        return item ? new ObjectId(item.id) : null;
    }

    function getSubId(parentId) {
        var deferred = Q.defer();

        model.find(_CD(parentId, 'parent'), function(err, result) {
            if (err) {
                throw err;
            }
            deferred.resolve(result.map(getId));
        });
        return deferred.promise;
    }
    return deferred.promise;
}

function _CD(items, name) {
    if (!_.isArray(items)) {
        items = [items];
    }
    var condition = {};
    var length = items.length;
    if (length === 1) {
        condition[name] = items[0];
    } else if (length > 1) {
        condition[name] = {
            $in: items
        };
    }
    return condition;
}