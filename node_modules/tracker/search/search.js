/**
 * search logs
 *
 */

'use strict';


var Q = require('q');
var Log = require('../model/log');
var _ = require('lodash');
var Project = require('../model/project');
var Task = require('../model/Task');
var Version = require('../model/version');
var extend = require('extend');
var Moment = require('moment');


var searchHelper = require('./searchHelper');


var NOT_EMPTY = function(val) {
    return !!val;
};


exports.query = function(options) {
    var deferred = Q.defer();
    options = _.extend({
        populate: true
    }, options);
    searchHelper.preprocessQuery(options, ['projects', 'tags', 'peoples', 'classes', 'versions', 'tasks']);
    queryLog(options, function(result) {
        if (_.isArray(result)) {
            result = result.map(function(item) {
                if (item.toJSON) {
                    return item.toJSON();
                }
                return item;
            });
        }
        deferred.resolve(result);
    }, function(err) {
        deferred.reject(err);
    });
    return deferred.promise;
};

function getOperator(str) {
    var operators = { '>' : '$gt', '<': '$lt', '>=': '$gte', '<=': '$lte'};
    return operators[str];
}

function queryLog(options, onSuccess, onError) {
    var conditions = searchHelper.getQueryConditions(options);
    if (!conditions.$and) {
        conditions.$and = [];
    }
    if (options.date) {
        conditions.$and.push({
            date: new Date(options.date)
        });
    } else {
        var dateCondition;
        if (options.start) {
            dateCondition = { $gte: Moment(options.start).startOf('day').toDate() };
        }
        if (options.end) {
            dateCondition = extend({}, dateCondition, { $lt: Moment(options.end).endOf('day').toDate()});
        }
        if (dateCondition) {
            conditions.$and.push({date: dateCondition});
        }
    }
    if (options.startTime) {
        conditions.$and.push({
            start: { $gte: Moment(options.startTime).toDate() }
        });
    }

    if (options.endTime) {
        conditions.$and.push({
            end: { $lte:  Moment(options.endTime).toDate() }
        });
    }

    if (options.len) {
        var lenConditions = options.len.split('AND');
        var condition = {};
        lenConditions.forEach(function (lenCondition) {
            var numStr = lenCondition.match(/\d+/, ''),
                operatorStr = lenCondition.replace(/\d+/, ''),
                num;
            if (numStr) {
                num = parseInt(numStr, 10);
                if (!operatorStr) {
                    condition = num;
                } else if (operatorStr !== '=') {
                    condition[getOperator(operatorStr)] = num;
                } else {
                    condition = num;
                }
            }
        });
        conditions.$and.push({
            len: condition
        });
    }
    if (_.isEmpty(conditions.$and)) {
        conditions = {};
    }
    var hasMatchIds = function(idConditions, userFilters) {
        if (_.isEmpty(idConditions)) {
            return false;
        }
        return userFilters.reduce(function(result, filterName) {
            return result && idConditions.filter(function(condition) {
                return !_.isEmpty(condition[filterName]);
            }).length > 0;
        }, true);
    };
    searchHelper.getIds(options).then(function (idsConditions) {
        var userFilters = ['project', 'task', 'version'].filter(function(filterName) {
            return options[filterName + 's']; //append 's' because options is plural, like projects;
        });
        //if can't find any suit ids, then no need for logs query
        //return empty array immediately
        if (!_.isEmpty(userFilters) && !hasMatchIds(idsConditions, userFilters)) {
            onSuccess([]);
            return;
        }
        var queryOptions = getQueryOptions(options);
        conditions.$and = (conditions.$and || []).concat(idsConditions);
        if (_.isEmpty(conditions.$and)) {
            conditions = {};
        }
        var args = [
            conditions,
            options.fields || null,
            queryOptions
        ];
        var sortOption = _.extend({start: 1}, searchHelper.getSortParams(options.sort));
        var groupOption = searchHelper.getGroupParams(options.group);
        if (!groupOption && !options.sum) {
            //console.log('##### find :' + JSON.stringify(conditions));
            var promise = Log.find.apply(Log, args);
            if (options.populate) {
                promise = promise.populate([{
                    path: 'project'
                }, {
                    path: 'task'
                }, {
                    path: 'version'
                }]);
            }
            promise.sort(sortOption)
                .exec(function(err, logs) {
                    if (err) {
                        onError(err);
                        return;
                    }
                    //populate sub task
                    var tasks = logs.map(function(log) {
                        return log.task;
                    }).filter(NOT_EMPTY);
                    var promise = Task.populate(tasks, 'parent');
                    promise.then(function() {
                        onSuccess(logs);
                    }).end();
                });
        } else {
            //console.log('##### aggregate :' + JSON.stringify(conditions));
            var aggregate = Log.aggregate({
                $match: conditions
            }).sort(sortOption);

            if (options.group && options.group.indexOf('classes') >= 0) {
               aggregate = aggregate.unwind("classes");
            }

            if (options.group && options.group.indexOf('tags') >= 0) {
               aggregate = aggregate.unwind("tags");
            }

            if (options.group && options.group.indexOf('peoples') >= 0) {
               aggregate = aggregate.unwind("peoples");
            }


            if (options.sum) {
                aggregate = aggregate.group({
                    _id: groupOption || null,
                    totalTime: {$sum: '$len'}
                }).sort({totalTime: -1});
            } else {
                aggregate = aggregate.group({
                    _id: groupOption,
                    logs: { $push: "$$ROOT" }
                });
            }
            if (options.limit) {
                aggregate = aggregate.limit(parseInt(options.limit, 10));
            }
            var map = {
                project: Project,
                task: Task,
                version: Version
            };
            aggregate.exec(function (err, result) {
                if (err) {
                    return onError(err);
                }
                function populate (group) {
                    var promise;
                    var singleGroup = (group.split(' ').length === 1);
                    function wrap(p) {
                        if (promise) {
                            promise = promise.then(function () {
                                return p;
                            });
                        } else {
                            promise = p;
                        }
                    }
                    if (singleGroup) {
                        var model = map[group];
                        var select = 'name';
                        if (model) {
                            if (group === 'task') {
                                select += ' parent';
                            }
                            return model.populate(result, [{path: '_id', select: select}]);
                        }
                    } else {
                        if (group.indexOf('project') >= 0) {
                            wrap(Project.populate(result, [{path: '_id.project', select: 'name'}]));
                        }

                        if (group.indexOf('version') >= 0) {
                            wrap(Version.populate(result, [{path: '_id.version', select: 'name'}]));
                        }

                        if (group.indexOf('task') >= 0) {
                            wrap(Task.populate(result, [{path: '_id.task', select: 'name parent'}]));
                        }
                    }
                    return promise;
                }
                if (options.group) {
                    var tmpArr = options.group.split(' ');
                    var noPopulate = tmpArr.length === 1 && tmpArr[0].indexOf('date') === 0;
                    if (options.populate && !noPopulate && map[options.group]) {
                        populate(options.group).then(function (result) {
                            onSuccess(result);
                        });
                    } else {
                        onSuccess(result);
                    }
                } else {
                    onSuccess(result);
                }
                
            });
        }
    });
}

function getQueryOptions(usrOptions) {
    var queryOptions = _.pick(usrOptions, ['limit', 'skip']);
    return queryOptions;
}
