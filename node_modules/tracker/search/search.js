/**
 * search logs
 *
 */

'use strict';


var Q = require('q');
var Log = require('../model/log');
var _ = require('lodash');
var Project = require('../model/project');
var Task = require('../model/Task');
var Version = require('../model/version');
var extend = require('extend');
var Moment = require('moment');
var mongoose = require('mongoose');
var ObjectId = mongoose.Types.ObjectId;


var searchHelper = require('./searchHelper');


var NOT_EMPTY = function(val) {
    return !!val;
};


exports.query = function(options) {
    var deferred = Q.defer();
    options = _.extend({
        populate: true
    }, options);
    options.count = options.count == 'true';
    searchHelper.preprocessQuery(options, ['projects', 'tags', 'peoples', 'classes', 'versions', 'tasks']);
    queryLog(options, function(result) {
        if (_.isArray(result)) {
            result = result.map(function(item) {
                if (item.toJSON) {
                    return item.toJSON();
                }
                return item;
            });
        }
        deferred.resolve(result);
    }, function(err) {
        deferred.reject(err);
    });
    return deferred.promise;
};

function getOperator(str) {
    var operators = { '>' : '$gt', '<': '$lt', '>=': '$gte', '<=': '$lte'};
    return operators[str];
}

exports.classify = function () {
    var deferred = Q.defer();
    function aggregateProject() {
        var deferred = Q.defer();
        Log.aggregate({
            $group: {
                _id: '$project',
                totalTime: {$sum: '$len'}
            }
        }).exec(function (err, projects) {
            if (err) {
                return deferred.reject(err);
            }
            projects = projects.filter(function (project) {
                return project && project._id;
            });
            Project.populate(projects, [{path: '_id', select: 'name _id'}])
                   .then(function (result) {
                        deferred.resolve(result);
                    });
        });
        return deferred.promise;
    }

    function aggregateVersion(projects) {
        return Q.allSettled(projects.map(function (project) {
            if (!project || !project._id || !project._id._id) {
                return null;
            }
            return Log.aggregate({
                $match: {
                    project: new ObjectId(project._id._id)
                }
            }).group({
                _id: '$version',
                totalTime: {$sum: '$len'}
            }).exec().then(function (versions) {
                versions = versions.filter(function (version) {
                    return version && version._id;
                });
                return Version.populate(versions, [{path: '_id', select: 'name _id'}]);
            }).then(function (versions) {
                project.versions = versions;
            });
        })).then(function () {
            return projects;
        });
    }

    function aggregateTask(projects) {
        var allVersions = projects.reduce(function (all, project) {
            return all.concat(project.versions || []);
        }, []);
        return Q.allSettled(allVersions.map(function (version) {
            if (!version || !version._id || !version._id._id) {
                return null;
            }
            return Log.aggregate({
                $match: {
                    version: new ObjectId(version._id._id)
                }
            }).group({
                _id: '$task',
                totalTime: {$sum: '$len'}
            }).exec().then(function (tasks) {
                return Task.populate(tasks, [{path: '_id', select: 'name _id parent'}]);
            }).then(function (tasks) {
                var parentTasks;
                tasks = tasks.filter(function (t) {
                    return t && t._id && t._id._id;
                });
                parentTasks = tasks.filter(function (task) {
                    if (task._id && task._id._id && !task._id.parent) {
                        task.children = [];
                        return true;
                    }
                    return false;
                });
                var task, pTask, pid, tpid;
                for (var i = 0; i < tasks.length; i++) {
                    task = tasks[i];
                    if (!task._id || !task._id.parent) { continue; }
                    for (var j = 0, plen = parentTasks.length; j < plen; j++) {
                        pTask = parentTasks[j];
                        if (!pTask._id) {
                            continue;
                        }
                        tpid = task._id.parent;
                        pid = pTask._id._id;
                        if ( pid && tpid && tpid.toString() === pid.toString()) {
                            if (pTask.autofill) {
                                pTask.totalTime += task.totalTime;
                            }
                            pTask.children.push(task);
                            break;
                        }
                    }
                    if (j === plen) {
                        parentTasks.push({
                            autofill: true,
                            _id: {_id: task._id.parent, name: ''},
                            totalTime: task.totalTime,
                            children: [task]
                        });
                    }
                }
                version.tasks = parentTasks;
            });
        })).then(function () {
            return projects;
        });
    }

    aggregateProject()
        .then(aggregateVersion)
        .then(aggregateTask)
        .then(function (result) {
            deferred.resolve(result);
        }, function (err) {
            console.log(err);
        }).catch(function (err) {
            deferred.reject(err);
        });

    return deferred.promise;
};

function queryLog(options, onSuccess, onError) {
    var conditions = searchHelper.getQueryConditions(options);
    if (!conditions.$and) {
        conditions.$and = [];
    }
    if (options.date) {
        conditions.$and.push({
            date: new Date(options.date)
        });
    } else {
        var dateCondition;
        if (options.start) {
            dateCondition = { $gte: Moment(options.start).startOf('day').toDate() };
        }
        if (options.end) {
            dateCondition = extend({}, dateCondition, { $lt: Moment(options.end).endOf('day').toDate()});
        }
        if (dateCondition) {
            conditions.$and.push({date: dateCondition});
        }
    }
    if (options.startTime) {
        conditions.$and.push({
            start: { $gte: Moment(options.startTime).toDate() }
        });
    }

    if (options.endTime) {
        conditions.$and.push({
            end: { $lte:  Moment(options.endTime).toDate() }
        });
    }

    if (options.len) {
        var lenConditions = options.len.split('AND');
        var condition = {};
        lenConditions.forEach(function (lenCondition) {
            var numStr = lenCondition.match(/\d+/, ''),
                operatorStr = lenCondition.replace(/\d+/, ''),
                num;
            if (numStr) {
                num = parseInt(numStr, 10);
                if (!operatorStr) {
                    condition = num;
                } else if (operatorStr !== '=') {
                    condition[getOperator(operatorStr)] = num;
                } else {
                    condition = num;
                }
            }
        });
        conditions.$and.push({
            len: condition
        });
    }
    if (_.isEmpty(conditions.$and)) {
        conditions = {};
    }
    var hasMatchIds = function(idConditions, userFilters) {
        if (_.isEmpty(idConditions)) {
            return false;
        }
        return userFilters.reduce(function(result, filterName) {
            return result && idConditions.filter(function(condition) {
                return !_.isEmpty(condition[filterName]);
            }).length > 0;
        }, true);
    };
    searchHelper.getIds(options).then(function (idsConditions) {
        var userFilters = ['project', 'task', 'version'].filter(function(filterName) {
            return options[filterName + 's']; //append 's' because options is plural, like projects;
        });
        //if can't find any suit ids, then no need for logs query
        //return empty array immediately
        if (!_.isEmpty(userFilters) && !hasMatchIds(idsConditions, userFilters)) {
            onSuccess([]);
            return;
        }
        var queryOptions = getQueryOptions(options);
        conditions.$and = (conditions.$and || []).concat(idsConditions);
        if (_.isEmpty(conditions.$and)) {
            conditions = {};
        }
        var args = [
            conditions,
            options.fields || null,
            queryOptions
        ];
        var sortOption = _.extend({start: 1}, searchHelper.getSortParams(options.sort));
        var groupOption = searchHelper.getGroupParams(options.group);
        if (options.count === true) {
             Log.count(conditions, function (err, res) {
                if (err) {
                    return onError(err);
                }
                onSuccess({
                    count: res
                });
             });
        }
        if (!groupOption && !options.sum) {
            //console.log('##### find :' + JSON.stringify(conditions));
            var promise = Log.find.apply(Log, args);
            if (options.populate) {
                promise = promise.populate([{
                    path: 'project'
                }, {
                    path: 'task'
                }, {
                    path: 'version'
                }]);
            }
            promise.sort(sortOption)
                .exec(function(err, logs) {
                    if (err) {
                        onError(err);
                        return;
                    }
                    //populate sub task
                    var tasks = logs.map(function(log) {
                        return log.task;
                    }).filter(NOT_EMPTY);
                    var promise = Task.populate(tasks, 'parent');
                    promise.then(function() {
                        onSuccess(logs);
                    }).end();
                });
        } else {
            //console.log('##### aggregate :' + JSON.stringify(conditions));
            var aggregate = Log.aggregate({
                $match: conditions
            }).sort(sortOption);

            if (options.group && options.group.indexOf('classes') >= 0) {
               aggregate = aggregate.unwind("classes");
            }

            if (options.group && options.group.indexOf('tags') >= 0) {
               aggregate = aggregate.unwind("tags");
            }

            if (options.group && options.group.indexOf('peoples') >= 0) {
               aggregate = aggregate.unwind("peoples");
            }


            if (options.sum) {
                console.log(groupOption);
                aggregate = aggregate.group({
                    _id: groupOption || null,
                    totalTime: {$sum: '$len'}
                }).sort({totalTime: -1});
            } else {
                aggregate = aggregate.group({
                    _id: groupOption,
                    logs: { $push: "$$ROOT" }
                });
            }
            if (options.limit) {
                aggregate = aggregate.limit(parseInt(options.limit, 10));
            }
            var map = {
                project: Project,
                task: Task,
                version: Version
            };

            aggregate.exec(function (err, result) {
                if (err) {
                    return onError(err);
                }
                function populate (group) {
                    var promise;
                    var singleGroup = (group.split(' ').length === 1);
                    function wrap(p) {
                        if (promise) {
                            promise = promise.then(function () {
                                return p;
                            });
                        } else {
                            promise = p;
                        }
                    }
                    if (singleGroup) {
                        var model = map[group];
                        var select = 'name';
                        if (model) {
                            if (group === 'task') {
                                select += ' parent';
                            }
                            return model.populate(result, [{path: '_id', select: select}]);
                        }
                    } else {
                        if (group.indexOf('project') >= 0) {
                            wrap(Project.populate(result, [{path: '_id.project', select: 'name'}]));
                        }

                        if (group.indexOf('version') >= 0) {
                            wrap(Version.populate(result, [{path: '_id.version', select: 'name'}]));
                        }

                        if (group.indexOf('task') >= 0) {
                            wrap(Task.populate(result, [{path: '_id.task', select: 'name parent'}]));
                        }
                    }
                    return promise;
                }
                if (options.group) {
                    var tmpArr = options.group.split(' ');
                    var noPopulate = tmpArr.length === 1 && tmpArr[0].indexOf('date') === 0;
                    if (options.populate && !noPopulate && map[options.group]) {
                        populate(options.group).then(function (result) {
                            onSuccess(result);
                        });
                    } else {
                        onSuccess(result);
                    }
                } else {
                    onSuccess(result);
                }
                
            });
        }
    });
}

function getQueryOptions(usrOptions) {
    var queryOptions = _.pick(usrOptions, ['limit', 'skip']);
    return queryOptions;
}
