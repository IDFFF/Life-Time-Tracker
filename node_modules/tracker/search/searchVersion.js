var Q = require('q');
var _ = require('lodash');
var Moment = require('moment');
var ObjectId = require('mongoose').Types.ObjectId;
var extend = require('extend');
//models
var Version = require('../model/version');
var Log = require('../model/log');
var Task = require('../model/Task');



exports.query = function (options) {
    options = extend({}, options);
    if (options.id) {
        console.log(options.id);
        return queryVersionById(options.id);
    } else {
        return queryVersionsByConditions(options);
    }
};


function queryVersionsByConditions(options) {
    var deferred = Q.defer();
    var conditions = getQueryConditions(options);
    var queryOptions = getQueryOptions(options);
    var query = Version.find(conditions, null, queryOptions);
    query.exec(function (err, versions) {
        if (err) {
            deferred.reject(err);
            return;
        }
        if (_.isEmpty(versions)) {
            deferred.resolve([]);
            return;
        }
        deferred.resolve(versions);
    });

    return deferred.promise;
}

function queryVersionById(id) {
    var deferred = Q.defer();
    if (!id) {
        deferred.resolve(null);
    }
    Version.findOne({_id: id}, function(err, version) {
        if (err) {
            deferred.reject(err);
            return;
        }
        if (_.isEmpty(version)) {
            deferred.resolve(null);
            return;
        }
        aggregateVersion(version).then(function (result) {
            console.log(result);
            deferred.resolve(extend(version.toJSON(), result));
        }).catch(function (err) {
            deferred.reject(err);
        });
    });
    return deferred.promise;
}


function getQueryConditions(options) {
    var conditions = [],
        timeCondition;
    if (options.start && options.end) {
        timeCondition.push({
            createTime: {
                $gt: new Moment(options.start).startOf('day').toDate(),
                $lt: new Moment(options.end).endOf('day').toDate()
            }
        });

        timeCondition.push({
            lastActiveTime: {
                $gt: new Moment(options.start).startOf('day').toDate(),
                $lt: new Moment(options.end).endOf('day').toDate()
            }
        });

        timeCondition.push({
            $and: [{
                lastActiveTime: { $gte: new Moment(options.end).endOf('day').toDate() }
            }, {
                createTime: {$lte: new Moment(options.start).startOf('day').toDate() }
            }]
        });
    }
    if (options.projectId) {
        conditions.push({
            projectId: new ObjectId(options.projectId)
        });
    }

    if (options.name) {
        conditions.push({
            name: options.name
        });
    }

    if (timeCondition) {
        conditions.push(timeCondition);
    }

    if (!_.isEmpty(conditions)) {
        return {
            $and: conditions
        };
    }
    return null;
}

function getQueryOptions(userOptions) {
    var queryOptions = _.pick(userOptions, ['limit', 'skip']);
    //默认按照最后活动时间倒序排列
    queryOptions.sort = {createTime: -1};
    return queryOptions;
}



function aggregateVersion(version) {
    var deferred = Q.defer();
    var versionId = version.id;
    var aggregateResult = {};
    Log.aggregate()
        .match({version: new ObjectId(versionId)})
        .group({_id: '$version', totalTime: {$sum: "$len"}})
        .exec()
        .then(function (result) {
            var sumData = result[0];
            aggregateResult.totalTime = sumData ? sumData.totalTime : 0;
        })
        .then(function () {
            Task.count({versionId: versionId}, function (err, count) {
                if (err) {
                    Msg.error('failed to calculate task count', err);
                    return deferred.resolve(err);
                }
                console.log(count);
                aggregateResult.taskCount = count;
                deferred.resolve(aggregateResult);
            });
        }).on('reject', function (err) {
            deferred.reject(err);
        });
    return deferred.promise;
}