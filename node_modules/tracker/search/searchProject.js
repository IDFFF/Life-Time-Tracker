var Q = require('q');
var _ = require('lodash');
var Moment = require('moment');
var Msg = require('../message');
var ObjectId = require('mongoose').Types.ObjectId;

//models
var Project = require('../model/project');
var Task = require('../model/Task');
var Log = require('../model/log');
var Version = require('../model/version');
var extend = require('extend');

exports.query = function (options) {
    if (options.versions) {
        options.versions = (options.versions === 'true');
    }
    options = extend({aggregate: true, versions: true}, options);
    console.log(options);
    if (options.id) {
        console.log('query project by id');
        return queryProjectById(options);
    } else {
        return queryProjects(options);
    }
};

function queryProjects(options) {
    var start = new Date().getTime();
    var deferred = Q.defer();
    queryProjectsByCondition(options, function(projects) {
        deferred.resolve(projects.map(function(project) {
            var obj = project.toJSON();
            obj.id = project.id;
            if (project.lastTasks) {
                obj.lastTasks = project.lastTasks.map(function (task) {
                    return task.toJSON();
                });
            }
            if (project.versions) {
                obj.versions = project.versions.map(function (version) {
                    return version.toJSON();
                });
            }
            obj.taskCount = project.taskCount;
            obj.totalTime = project.totalTime;
            return obj;
        }));
        console.log('query projects cost' + (new Date().getTime() -start));
    }, function(err) {
        console.error(err.stack);
        deferred.reject(err);
    });
    return deferred.promise;
}

function queryProjectById(options) {
    var deferred = Q.defer();
    if (!options.id) {
        deferred.resolve([]);
    }
    Project.findOne({_id: options.id}, function(err, project) {
        if (err) {
            deferred.reject(err);
            return;
        }
        if (_.isEmpty(project)) {
            deferred.resolve(null);
            return;
        }
        appendVersionsToProject(project).then(function () {
            return aggregateProject(project, options);
        }).then(function (project) {
            var obj = project.toJSON();
            if (project.lastTasks) {
                obj.lastTasks = project.lastTasks.map(function (task) {
                    return task.toJSON();
                });
            }
            if (project.versions) {
                obj.versions = project.versions.map(function (version) {
                    return version.toJSON();
                });
            }
            obj.taskCount = project.taskCount;
            obj.totalTime = project.totalTime;
            deferred.resolve(obj);
        }).fail(function (err) {
            deferred.reject(err);
        });
    });
    return deferred.promise;
}



function queryProjectsByCondition(options, onSuccess, onError) {
    var conditions = getQueryConditions(options);
    var queryOptions = getQueryOptions(options);
    var args = [conditions, options.fields || null, queryOptions];
    Project.find.apply(Project, args).exec(function (err, projects) {
        if (err) {
            onError(err);
            return;
        }
        if (projects.length === 0) {
            return onSuccess(projects);
        }
        if (options.versions) {
            Q.allSettled(projects.map(function (project) {
                return appendVersionsToProject(project);
            })).then(function () {
                if (options.aggregate) {
                    //append more info to each project
                    Q.allSettled(projects.map(function (project) {
                        return aggregateProject(project, options);
                    })).then(function () {
                        onSuccess(projects);
                    }).fail(function (err) {
                        onError(err);
                    });
                } else {
                    onSuccess(projects);
                }
            }).fail(function (err) {
                onError(err);
            });
        } else {
            onSuccess(projects);
        }
    });
}

function appendVersionsToProject(project) {
    var deferred = Q.defer();
    Version.find({projectId: new ObjectId(project._id)})
        .sort({createdTime: -1, lastActiveTime: -1}).exec()
        .then(function (versions) {
            project.versions = versions;
            deferred.resolve(project);
        }).on('reject', function (err) {
            console.error(err.stack);
            deferred.reject(err);
        });
    return deferred.promise;
}

function aggregateProject(project) {
    var deferred = Q.defer();
    var projectId = project.id;
    Log.aggregate()
        .match({project: new ObjectId(projectId)})
        .group({_id: '$project', totalTime: {$sum: "$len"}})
        .exec()
        .then(function (result) {
            var sumData = result[0];
            project.totalTime = sumData ? sumData.totalTime : 0;
        })
        .then(function () {
            Task.count({projectId: projectId}, function (err, count) {
                if (err) {
                    Msg.error('failed to search task count', err);
                    return deferred.resolve(err);
                }
                project.taskCount = count;
                Task.find({projectId: projectId})
                    .sort({lastActiveTime: -1})
                    .limit(2)
                    .exec()
                    .then(function (lastTasks) {
                        project.lastTasks = lastTasks;
                        return deferred.resolve(project);
                    }).on('reject', function (err) {
                        Msg.error('failed when aggreate project', err);
                        return deferred.reject(err);
                    });
            });
        }).on('reject', function (err) {
            deferred.reject(err);
        });
    return deferred.promise;
}

function getQueryConditions(options) {
    var conditions = [];
    if (options.start && options.end) {
        conditions.push({
            createdTime: {
                $gt: new Moment(options.start).startOf('day').toDate(),
                $lt: new Moment(options.end).endOf('day').toDate()
            }
        });

        conditions.push({
            lastActiveTime: {
                $gt: new Moment(options.start).startOf('day').toDate(),
                $lt: new Moment(options.end).endOf('day').toDate()
            }
        });

        conditions.push({
            $and: [{
                lastActiveTime: { $gte: new Moment(options.end).endOf('day').toDate() }
            }, {
                createdTime: {$lte: new Moment(options.start).startOf('day').toDate() }
            }]
        });
    }

    if (options.name) {
        conditions.push({
            name: options.name
        });
    }

    if (!_.isEmpty(conditions)) {
        return {
            $or: conditions
        };
    }
    return null;
}

function getQueryOptions(userOptions) {
    var queryOptions = _.pick(userOptions, ['limit', 'skip']);
    //默认按照最后活动时间倒序排列
    queryOptions.sort = {lastActiveTime: -1};
    return queryOptions;
}