var Q = require('q');
var _ = require('lodash');
var Moment = require('moment');
var Msg = require('../message');
var ObjectId = require('mongoose').Types.ObjectId;

//models
var Project = require('../model/project');
var Task = require('../model/task');
var Log = require('../model/log');

exports.query = function(options) {
    var deferred = Q.defer();
    queryProjects(options, function(projects) {
        deferred.resolve(projects.map(function(project) {
            var obj = project.toJSON();
            if (project.lastTasks) {
                obj.lastTasks = project.lastTasks.map(function (task) {
                    return task.toJSON();
                });
            }
            obj.taskCount = project.taskCount;
            obj.totalTime = project.totalTime;
            return obj;
        }));
    }, function(err) {
        deferred.reject(err);
    });
    return deferred.promise;
};


function queryProjects(options, onSuccess, onError) {
    var conditions = getQueryConditions(options);
    var queryOptions = getQueryOptions(options);
    var args = [conditions, options.fields || null, queryOptions];
    Project.find.apply(Project, args).exec(function (err, projects) {
        if (err) {
            onError(err);
            return;
        }
        //append more info to each project
        var lastIndex = projects.length - 1;
        projects.forEach(function (project, index) {
            var projectId = project.id;

            Log.aggregate()
                .match({project: new ObjectId(projectId)})
                .group({_id: '$project', totalTime: {$sum: "$len"}})
                .exec()
                .then(function (result) {
                    var sumData = result[0];
                    project.totalTime = sumData.totalTime;
                })
                .then(function () {
                    Task.count({projectId: projectId}, function (err, count) {
                        if (err) {
                            Msg.error('failed to search task count', err);
                            return;
                        }
                        project.taskCount = count;
                    });

                    Task.find({projectId: projectId}).sort({lastActiveTime: -1}).limit(2).exec(function (err, result) {
                        if (err) {
                            Msg.error('failed to search last task count', err);
                            return;
                        }
                        project.lastTasks = result;
                        if (index === lastIndex) {
                            return onSuccess(projects);
                        }
                    });
                });
        });
    });
}

function getQueryConditions(options) {
    var conditions = [];
    if (options.start && options.end) {
        conditions.push({
            createdTime: {
                $gt: new Moment(options.start).startOf('day').toDate(),
                $lt: new Moment(options.end).endOf('day').toDate()
            }
        });

        conditions.push({
            lastActiveTime: {
                $gt: new Moment(options.start).startOf('day').toDate(),
                $lt: new Moment(options.end).endOf('day').toDate()
            }
        });

        conditions.push({
            $and: [{
                lastActiveTime: { $gte: new Moment(options.end).endOf('day').toDate() }
            }, {
                createdTime: {$lte: new Moment(options.start).startOf('day').toDate() }
            }]
        });
    }
    if (!_.isEmpty(conditions)) {
        return {
            $or: conditions
        };
    }
    return null;
}

function getQueryOptions(userOptions) {
    var queryOptions = _.pick(userOptions, ['limit', 'skip']);
    //默认按照最后活动时间倒序排列
    queryOptions.sort = {lastActiveTime: -1};
    return queryOptions;
}