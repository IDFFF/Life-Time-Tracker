/**
 * import logs to database
 */

'use strict';

var scanner = require('./scanner');
var Q = require('q');
var Moment = require('moment');
var extend = require('extend');
var helper = require('./helper');

/** Models */

var Log = require('./model/log');
var Project = require('./model/project');
var ProjectObject = require('./model/fundament/Project');
var Task = require('./model/Task');
var Version = require('./model/version');
var Tag = require('./model/tag');
var Stat = require('./model/Stat');
var LogClass = require('./model/LogClass');
var randomColor = require('randomcolor');


/*statists*/
var DayStat = require('./statists/day');


//var syncNoteSig = require('./globalSignals').syncNote;
var Msg = require('./message');
var _ = require('lodash');


//import note to database after sync success;
/*syncNoteSig.add(function (files) {
    importFromLogFile({
        files: files
    });
});*/

var importedLogCount = 0;

/*
process.on('message', function (msg) {
    if (msg.command === 'import_log') {
        Msg.log('%%%%%%%%%%importlog', msg);
        importLogContent(msg.date, msg.logContent).then(function (a, b) {
            Msg.log(a,b);
            process.send({success: true});
        }).catch(function (err) {
            process.send({success: false, error: err});
        });
    }
});*/

/**
 * import data from log file into database
 * @param  {Object} options
 * @return {Promise}
 */
function importFromLogFile(options) {
    var deferred = Q.defer();
    //scan the data
    scanner.scan(options)
        .then(function (scanResult) {
            var days = scanResult.days || [scanResult];
            importLogs(days).then(function () {
                deferred.resolve();
            });
        }).then(function () {
            Msg.success('logs have been imported into database successfully.');
        }).catch(function (err) {
            Msg.error('Something wrong happen when imported logs into database.');
            deferred.reject(err);
        });
    return deferred.promise;
}


var waitToImportedLogCount = 0,
    totalNumberRemoved = 0;
function importLogs(days) {
    waitToImportedLogCount = 0;
    totalNumberRemoved = 0;

    var promise = days.reduce(function (promise, day) {
        waitToImportedLogCount += day.logs.length;
        return promise.then(importDay.bind(null, day));
    }, Q(1));
    Msg.info('Import Logs Count:' + waitToImportedLogCount);
    return promise;
}

function importDay(day) {
    Msg.log('import', day);
    var deferred = Q.defer();
    if (_.isEmpty(day)) {
        return Q(1);
    }
    var logs = day.logs;
    var date = day.date;
    waitToImportedLogCount = logs.length;
    totalNumberRemoved = 0;
    var t1 = Date.now(), t2, t3, t4;

    //remove the same day's log before import
    Log.remove({
        date: new Date(day.date)
    }, function (err, numberRemoved) {
        t2 = Date.now();
        Msg.log('remove log cost: ' + (t2 - t1));
        if (err) {
            Msg.error('清空失败' + date, err);
            return deferred.reject(err);
        }
        if (!numberRemoved) {
            Msg.debug('不需要清空' + date);
        } else {
            Msg.debug('已清空' + date + '的数据, affected:' + numberRemoved);
        }
        totalNumberRemoved += numberRemoved;
        if (_.isEmpty(logs)) {
            Msg.warn('[import log]' + date + '\'s have no log');
            return deferred.resolve();
        }
            //insert sequence, make sure that task will not repeat
        logs.reduce(function(promise, log) {
            return promise.then(importLog.bind(null, date, log));
        }, Q(1)).then(function () {
            t3 = Date.now();
            Msg.log('import log cost:' + (t3 - t2));
            return statAndSaveToDatabase(day);
        }).then(function () {
            t4 = Date.now();
            Msg.log('save and stat log cost:' + (t4 - t3));
            deferred.resolve();
            Msg.success('Successfully Import Day ' + date);
        }).catch(function (err) {
            Msg.log(err.stack);
            deferred.reject(err);
        });
    });
    return deferred.promise;
}


function statAndSaveToDatabase(day) {
    var deferred = Q.defer();
    var result = DayStat.dispose({dateStr: day.date}, day);
    Stat.findOne({date: new Moment(day.date).toDate()}, function (err, stat) {
        if (err) {
            return deferred.reject(err);
        }
        var now = new Moment().toDate();
        if (!stat) {
            Msg.log('create stat result' + day.date);
            Stat.create({
                date: new Moment(day.date).toDate(),
                result: result,
                createTime: now,
                updateTime: now
            }, function (err) {
                if (err) {
                    return deferred.reject(err);
                }
                deferred.resolve();
            });
        } else {
            Msg.log('update stat result' + day.date);
            stat.result = result;
            stat.updateTime = new Moment().toDate();
            stat.save(function (err) {
                if (err) {
                    return deferred.reject(err);
                }
                deferred.resolve();
            });
        }
    });
    return deferred.promise;
}


function importLog(date, log) {

    var deferred = Q.defer();
    log.project = log.projects[0];
    // import tags
    var logClasses = log.classes;
    var promises;
    if (!_.isEmpty(logClasses) ) {
        promises = logClasses.map(function (cls) {
            return cls ? importLogClass(cls) : Q(1);
        });
    } else {
        promises = [Q(1)];
    }
    Q.allSettled(promises).then(function () {
        return importTags(log.tags);
    }).then(function () {
        //import project
        if (!log.project && log.task) {
            log.project = new ProjectObject('Inbox', {});
        }
        return importProject(log.project, _.pick(log, ['tags', 'classes', 'start', 'end']));
    }).then(function (projectId) {
        //importVersion
        var version = null;
        var projectProgress = null;
        if (projectId) {
            projectProgress = log.project.progress;
        }
        version = log.version;
        if (log.project && log.project.version) {
            version = {name: log.project.version};
        }
        importVersion(version, {
            projectId: projectId,
            createTime: log.start,
            lastActiveTime: log.end || log.start
        }).then(function (versionId) {
            //import task;
            importTask(log.task, {
                projectId: projectId,
                versionId: versionId,
                tags: log.tags,
                createTime: log.start,
                lastActiveTime: log.end || log.start,
                hasSubTasks: !_.isEmpty(log.subTask)
            }).then(function (task) {
                var deferred = Q.defer();
                if (log.subTask) {
                    importTask(log.subTask, {
                        projectId: projectId,
                        versionId: versionId,
                        tags: log.tags,
                        createTime: log.start,
                        lastActiveTime: log.end || log.start,
                        parent: task
                    }).then(function (subTask) {
                        deferred.resolve({
                            task: task,
                            subTask: subTask
                        });
                    });
                } else {
                    return {
                        task: task
                    };
                }
                return deferred.promise;
            }).then(function (result) {
                //Msg.log(log.task, log.subTask);
                var savedTask = result.task,
                    savedSubTask = result.subTask;
                var taskId = null;
                if (savedTask) {
                    taskId = savedTask._id;
                }

                var subTaskId = null;
                if (savedSubTask) {
                    subTaskId = savedSubTask._id;
                }
                var progress = {
                    subTask: getProgress(log.subTask),
                    task: getProgress(log.task),
                    version: getProgress(log.version),
                    project: getProgress(log.project)
                };
                Msg.log(progress);
                saveLog({
                    project: projectId,
                    task: subTaskId || taskId,
                    subTask: subTaskId,
                    version: versionId,
                    progress: progress
                });

                function getProgress (obj) {
                    var progress = null;
                    if (obj && _.isNumber(obj.progress)) {
                        progress = obj.progress;
                    }
                    return progress;
                }

                function saveLog(refer) {
                    var logModel = new Log(_.extend({date: date}, log, refer));
                    logModel.save(function(err, log) {
                        if (err) {
                            Msg.error('Save Log failed!', err);
                        } else {
                            importedLogCount++;
                            //Msg.success('Import Log Success' + log.origin);
                            deferred.resolve();
                        }
                        if (importedLogCount === waitToImportedLogCount) {
                            Msg.success('Import Logs finished, count:' + importedLogCount);
                        }
                    });
                }
            }).catch(function (err) {
                Msg.error('import task of log failed!', err);
            });
        });
    }).catch(function (err) {
        Msg.error('import project fail', err);
    });
    return deferred.promise;
}

function importProject(project, attrs) {
    var tags = attrs.tags,
        classes = attrs.classes;
    var deferred = Q.defer();
    if (!project) {
        deferred.resolve(null);
        return deferred.promise;
    }
    var queryCondition = getProjectQueryCondition(project);
    //check the existence of project
    Project.findOne(queryCondition, function (err, result) {
        if (err) {
            throw err;
        }
        if (!result) {
            project.createdTime = new Moment(attrs.start).toDate();
            project.lastActiveTime = new Moment(attrs.end).toDate();
            project.tags = tags || [];
            project.classes = classes || [];
            var projectModel = new Project(project);
            //save to database
            projectModel.save(function (err, result) {
                if (err) {
                    Msg.error('Project' + ' create failed!' + JSON.stringify(project), err);
                    deferred.reject(err);
                    return;
                }
                Msg.success('Successfully save Project ' + project.name);
                deferred.resolve(result.id);
            });
        } else {
            var diffLastActiveTime = new Moment(attrs.end || attrs.start ).diff(result.lastActiveTime);
            var diffCreatedTime = new Moment(attrs.start).diff(result.createdTime);
            //update progress
            if (_.isNumber(project.progress)) {
                if (diffLastActiveTime >= 0) {
                    Msg.log('update progress of ' + result.name + ' to ' + project.progress);
                    result.progress = project.progress;
                } else {
                     Msg.log('no need to update progress, of ' + project.name + ' diff=' + diffLastActiveTime);
                }
            }
            if (diffCreatedTime < 0) {
                result.createdTime = new Moment(attrs.start).toDate();
                console.log('update createdTime ' + attrs.start);
                Msg.log('update createdTime ' + attrs.start);
            }
            if (diffLastActiveTime >= 0) {
                result.lastActiveTime = new Moment(attrs.end).toDate();
            }
            if (!_.isEmpty(tags)){
                result.tags.addToSet(tags);
            }
            result.attributes = extend({}, result.attributes, project.attributes);
            var resultClasses = result.classes;
            if (resultClasses && !_.isEmpty(classes)) {
                var appendClasses = [];
                classes.forEach(function (newCls) {
                    if (resultClasses.indexOf(newCls) < 0) {
                        appendClasses.push(newCls);
                    }
                });
                resultClasses.push.apply(resultClasses, appendClasses);
            }
            result.save(function (err, project, row) {
                if (err) {
                    Msg.error('Project' + ' update failed!' + JSON.stringify(project), err);
                    deferred.reject(err);
                    return;
                }
                Msg.debug('Project ' + project.name + ' exists, last active time updated, affected' + row+ 'record');
                deferred.resolve(project._id);
            });
        }
    });
    return deferred.promise;
}

function getProjectQueryCondition(project) {
    //var version = project.version;
    var queryCondition = {
        name: project.name,
    };
    /*
    if (version) {
        queryCondition.version = version;
    } else if (exceptVersion) {
        queryCondition.version = {$exists: false};
    }*/
    return queryCondition;
}




function importTask(taskObj, info) {
    var projectId = info.projectId,
        versionId = info.versionId,
        createTime = info.createTime,
        parent = info.parent,
        tags = info.tags,
        lastActiveTime = info.lastActiveTime;

    function appendInfo(taskObj) {
        if (taskObj.progress === 100 && lastActiveTime) {
            taskObj.completeTime = new Moment(lastActiveTime).toDate();
        }
        taskObj.projectId = projectId;
        taskObj.versionId = versionId;
        taskObj.createTime = createTime;
        taskObj.lastActiveTime = lastActiveTime;
        taskObj.parent = parent ? parent.id : null;
        return taskObj;
    }


    var deferred = Q.defer();
    if (!taskObj) {
        deferred.resolve({});
    } else {
        var condition = {name: taskObj.name};
        if (projectId) {
            condition.projectId = projectId;
        }
        if (versionId) {
            condition.versionId = versionId;
        }
        if (parent) {
            condition.parent = parent._id;
        } else {
            condition.parent = { $type: 10 };
        }
        Task.findOne(condition, function (err, task) {
            //if task already exist
            if (task) {
                Msg.debug('Task ' + taskObj.name + ' exist ');
                var diffLastActiveTime = new Moment(lastActiveTime).diff(task.lastActiveTime);
                if (_.isNumber(taskObj.progress)) {
                    if (diffLastActiveTime >= 0) {
                        Msg.log('update progress of ' + task.name + ' to ' + taskObj.progress + ' diff:' + diffLastActiveTime);
                        task.progress = taskObj.progress;
                    } else {
                        Msg.log('no need to update progress, of ' + task.name + ' diff=' + diffLastActiveTime);
                    }
                    if (taskObj.progress === 100 && lastActiveTime) {
                        task.completeTime = new Moment(lastActiveTime).toDate();
                    }
                }
                if (diffLastActiveTime >= 0) {
                    task.lastActiveTime = lastActiveTime;
                }
                var diffCreateTime = new Moment(createTime).diff(task.createTime);
                if (diffCreateTime < 0) {
                    task.createTime = new Moment(createTime).toDate();
                    Msg.log('update createdTime ' + createTime);
                }
                if (!_.isEmpty(tags)){
                    task.tags.addToSet(tags);
                }

                task.attributes = extend({}, task.attributes, taskObj.attributes);

                task.save(function (err, result, numberAffected) {
                    if (err) {
                        Msg.error('Task' + task.name + ' update failed!', err);
                        return deferred.reject(err);
                    }
                    Msg.debug('Task ' + task.name + ' exists, last active time updated, affected' + numberAffected + 'record');
                    addToParent(parent, result, function () {
                        deferred.resolve(result);
                    });
                });
            } else {
                taskObj = appendInfo(taskObj);
                taskObj.tags = tags || [];
                var taskModel = new Task(taskObj);
                taskModel.save(function (err, result) {
                    if (err) {
                        //Msg.error('Import Task' + taskObj.name, err);
                        return deferred.reject(err);
                    }
                    Msg.debug(result.name + ' import success. _id:' + result.id);
                    addToParent(parent, result, function () {
                        deferred.resolve(result);
                    });
                });
            }
        });
    }

    function addToParent(parent, child, cb) {
        if (!parent) {
            return cb();
        }
        parent.children.addToSet(child._id);
        parent.save(function (err, result) {
            if (err) {
                throw err;
            }
            cb(result);
        });
    }
    return deferred.promise;
}



function importVersion(versionObj, options) {
    var projectId = options.projectId;
    var deferred = Q.defer();
    var lastActiveTime = options.lastActiveTime;
    if (!versionObj) {
        deferred.resolve(null);
    } else {
        var condition = {
            name: versionObj.name,
            projectId: projectId
        };
        Version.findOne(condition, function (err, version) {
            if (err) {
                Msg.error('Failed create version ' + versionObj.name, err);
                deferred.reject(err);
                return;
            }
            if (version) {
                Msg.debug('Version ' + versionObj.name + ' exist ' + version.id);
                version.attributes = extend({}, version.attributes, versionObj.attributes);
                var diffLastActiveTime = new Moment(lastActiveTime).diff(version.lastActiveTime);
                if (_.isNumber(versionObj.progress)) {
                    if (diffLastActiveTime >= 0) {
                        Msg.log('update progress of ' + version.name + ' to ' + versionObj.progress + ' diff:' + diffLastActiveTime);
                        version.progress = versionObj.progress;
                    } else {
                        Msg.log('no need to update progress, of version ' + version.name);
                    }
                    if (versionObj.progress === 100 && lastActiveTime) {
                        version.completeTime = new Moment(lastActiveTime).toDate();
                    }
                }
                var diffCreateTime = new Moment(options.createTime).diff(version.createTime);
                if (diffCreateTime < 0) {
                    version.createTime = new Moment(options.createTime).toDate();
                    console.log('update createdTime ' + options.createTime);
                    Msg.log('update createdTime ' + options.createTime);
                }
                if (diffLastActiveTime >= 0) {
                    version.lastActiveTime = lastActiveTime;
                } else {
                    Msg.log('no need to update lastActiveTime of version ' + version.name);
                }
                Version.update({_id: version._id}, version, function (err, raw) {
                    if (err) {
                        Msg.error('Version' + version.name + ' update failed!', err);
                        return deferred.reject(err);
                    }
                    Msg.debug('Version' + version.name + ' exists and updated');
                    deferred.resolve(version._id);
                });
            } else {
                versionObj = extend(versionObj, _.pick(options, ['lastActiveTime', 'createTime', 'projectId']));
                if (versionObj.progress === 100 && lastActiveTime) {
                    versionObj.completeTime = new Moment(lastActiveTime).toDate();
                    Msg.log('complete version ');
                }
                var versionModel = new Version(versionObj);
                versionModel.save(function (err, result) {
                    var name = versionObj.name;
                    if (err) {
                        Msg.error('Import Version' + name, err);
                        return deferred.reject(err);
                    }
                    Msg.success('Successfully import version ' + name + ' _id:' + result.id);
                    deferred.resolve(result.id);
                });
            }
        });
    }
    return deferred.promise;
}


function importTags (tags) {
    if (!tags) {
        return Q(1);
    }
    if (!_.isArray(tags)) {
        tags = [tags];
    }
    return tags.reduce(function (promise, tag) {
        return promise.then(importTag(tag));
    }, Q(1));
}

function importTag (tag) {
    var deferred = Q.defer();
    Tag.count({name: tag}, function (err, count) {
        if (err) {
            return deferred.reject(err);
        }
        if (count === 0) {
            Tag.create({name: tag}, function (err, tag) {
                if (err) {
                    return deferred.reject(err);
                }
                Msg.success('Import tag success');
                deferred.resolve(true);
            });
        } else {
            return deferred.resolve(false);
        }
    });
    return deferred.promise;
}


function importLogClass (logClass) {
    var deferred = Q.defer();
    LogClass.findById(logClass, function (err, cls) {
        if (err) {
            Msg.error('insert log class while checking if log class exist ' + logClass + ' failed');
            return deferred.reject(err);
        }
        if (!cls) {
            LogClass.create({
                _id: logClass,
                name: logClass,
                color: randomColor({luminosity: 'dark'})
            }, function (err, cls) {
                if (err) {
                    Msg.error('insert log class while create ' + logClass + ' failed');
                    return deferred.reject(err);
                }
                deferred.resolve(cls);
            });
        } else {
            deferred.resolve(cls);
        }
    });
    return deferred.promise;
}



exports.importFromLogFile = importFromLogFile;
function importLogContent (date, logContent) {
    var logs;
    try {
        logs = helper.getLogs(logContent, date);
    } catch(e) {
        console.error(e.stack);
        return Q({logs: [],date: date});
    }
    return importDay({
        logs: logs,
        date: date
    });
}
exports.importLogContent = importLogContent;