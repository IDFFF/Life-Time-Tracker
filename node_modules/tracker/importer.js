/**
 * import logs to database
 */

'use strict';

var scanner = require('./scanner');
var Q = require('q');
var Log = require('./model/log');
var Project = require('./model/project');
var Task = require('./model/task');
var Version = require('./model/version');
var Moment = require('moment');
var extend = require('extend');


var syncNoteSig = require('./globalSignals').syncNote;
var Msg = require('./message');
var _ = require('lodash');


//import note to database after sync success;
syncNoteSig.add(function (files) {
    importFromLogFile({
        files: files
    });
});

var importedLogCount = 0;


/**
 * import data from log file into database
 * @param  {Object} options
 * @return {Promise}
 */
function importFromLogFile(options) {
    var deferred = Q.defer();
    //scan the data
    scanner.scan(options)
        .then(function (scanResult) {
            var days = scanResult.days || [scanResult];
            importLogs(days);
        }).then(function () {
            Msg.success('logs have been imported into database successfully.');
        }).catch(function (err) {
            Msg.error('Something wrong happen when imported logs into database.');
            throw err;
        });
    return deferred.promise;
}


var waitToImportedLogCount = 0,
    totalNumberRemoved = 0;
function importLogs(days) {
    waitToImportedLogCount = 0;
    totalNumberRemoved = 0;

    days.reduce(function (promise, day) {
        waitToImportedLogCount += day.logs.length;
        return promise.then(importDay.bind(null, day));
    }, Q(1));
    Msg.info('Import Logs Count:' + waitToImportedLogCount);
}

function importDay(day) {
    var deferred = Q.defer();
    var logs = day.logs;
    var date = day.date;
    if (_.isEmpty(logs)) {
        Msg.warn('[import log]' + date + '\'s have no log');
        return;
    }

    //remove the same day's log before import
    Log.remove({
        date: new Date(day.date)
    }, function (err, numberRemoved) {
        if (err) {
            Msg.error('清空失败' + date, err);
        }
        if (!numberRemoved) {
            Msg.debug('不需要清空' + date);
        } else {
            Msg.debug('已清空' + date + '的数据' + numberRemoved);
        }
        totalNumberRemoved += numberRemoved;
            //insert sequence, make sure that task will not repeat
        logs.reduce(function(promise, log) {
            return promise.then(importLog.bind(null, date, log));
        }, Q(1)).then(function () {
            deferred.resolve();
            Msg.success('Successfully Import Day ' + date);
        });
    });
    return deferred.promise;
}


function importLog(date, log) {
    var deferred = Q.defer();
    log.project = log.projects[0];
    //importProject
    importProject(log.project, _.pick(log, ['tags', 'classes', 'start', 'end']))
      .then(function (projectId) {
        //importVersion
        var version = null;
        if (log.project && log.project.version) {
            version = {name: log.project.version};
        }
        importVersion(version, {
            projectId: projectId,
            createTime: log.start,
            lastActiveTime: log.end
        }).then(function (versionId) {
            //import task;
            importTask(log.task, {
                projectId: projectId,
                versionId: versionId,
                createTime: log.start,
                lastActiveTime: log.end
            }).then(function (taskId) {
                //if have subTask, then save the subtask with parent task Id
                if (log.subTask) {
                    log.subTask.parent = taskId;
                    importTask(log.subTask, {
                        projectId: projectId,
                        lastActiveTime: log.start,
                        versionId: versionId,
                        createTime: log.end
                    }).then(function (subTaskId) {
                        saveLog({
                            project: projectId,
                            task: subTaskId,
                            version: versionId
                        });
                    });
                } else {
                    saveLog({
                        project: projectId,
                        task: taskId,
                        version: versionId
                    });
                }

                function saveLog(refer) {
                    var logModel = new Log(_.extend({date: date}, log, refer));
                    logModel.save(function(err, log) {
                        if (err) {
                            Msg.error('Save Log failed!', err);
                        } else {
                            importedLogCount++;
                            //Msg.success('Import Log Success' + log.origin);
                            deferred.resolve();
                        }
                        if (importedLogCount === waitToImportedLogCount) {
                            Msg.success('Import Logs finished, count:' + importedLogCount);
                        }
                    });
                }
            }).catch(function (err) {
                Msg.error('import task of log failed!', err);
            });
        });
    }).catch(function (err) {
        Msg.error('import project fail', err);
    });
    return deferred.promise;
}

function importProject(project, attrs) {
    var tags = attrs.tags,
        classes = attrs.classes;
    var deferred = Q.defer();
    if (!project) {
        deferred.resolve(null);
        return deferred.promise;
    }
    var queryCondition = getProjectQueryCondition(project);
    //check the existence of project
    Project.findOne(queryCondition, function (err, result) {
        if (err) {
            throw err;
        }
        if (!result) {
            project.createdTime = new Moment(attrs.start).toDate();
            project.lastActiveTime = new Moment(attrs.end).toDate();
            project.tags = tags || [];
            project.classes = classes || [];
            var projectModel = new Project(project);
            //save to database
            projectModel.save(function (err, result) {
                if (err) {
                    Msg.error('Project' + ' create failed!' + JSON.stringify(project), err);
                    deferred.reject(err);
                    return;
                }
                Msg.success('Successfully save Project ' + project.name);
                deferred.resolve(result.id);
            });
        } else {
            result.lastActiveTime = new Moment(attrs.end).toDate();
            if (!_.isEmpty(tags)){
                result.tags.addToSet(tags);
            }
            //update progress
            if (project.progress) {
                result.progress = project.progress;
            }
            var resultClasses = result.classes;
            if (resultClasses && !_.isEmpty(classes)) {
                var appendClasses = [];
                classes.forEach(function (newCls) {
                    var classExist = resultClasses.filter(function (cls) {
                        return cls.code === newCls.code;
                    }).length > 0;
                    if (!classExist) {
                        appendClasses.push(newCls);
                    }
                });
                resultClasses.push.apply(resultClasses, appendClasses);
            }
            result.save(function (err, proj, numberAffected) {
                if (err) {
                    Msg.error('Project' + ' update failed!' + JSON.stringify(project), err);
                    deferred.reject(err);
                    return;
                }
                Msg.debug('Project ' + proj.name + ' exists, last active time updated, affected' + numberAffected + 'record');
                deferred.resolve(proj.id);
            });
        }
    });
    return deferred.promise;
}

function getProjectQueryCondition(project) {
    //var version = project.version;
    var queryCondition = {
        name: project.name,
    };
    /*
    if (version) {
        queryCondition.version = version;
    } else if (exceptVersion) {
        queryCondition.version = {$exists: false};
    }*/
    return queryCondition;
}




function importTask(taskObj, info) {
    var projectId = info.projectId,
        versionId = info.versionId,
        createTime = info.createTime,
        lastActiveTime = info.lastActiveTime;
    var deferred = Q.defer();
    if (!taskObj) {
        deferred.resolve(null);
    } else {
        var condition = {name: taskObj.name};
        if (projectId) {
            condition.projectId = projectId;
        }
        if (versionId) {
            condition.versionId = versionId;
        }
        Task.findOne(condition, function (err, task) {
            //if task already exist
            if (task) {
                Msg.debug('Task ' + taskObj.name + ' exist ' + task.id);
                task.lastActiveTime = lastActiveTime;
                if (taskObj.progress) {
                    task.progress = taskObj.progress;
                }
                task.save(function (err, result, numberAffected) {
                    if (err) {
                        Msg.error('Task' + task.name + ' update failed!', err);
                        return;
                    }
                    Msg.debug('Task ' + task.name + ' exists, last active time updated, affected' + numberAffected + 'record');
                    deferred.resolve(result.id);
                });
            } else {
                taskObj.projectId = projectId;
                taskObj.versionId = versionId;
                taskObj.createTime = createTime;
                taskObj.lastActiveTime = lastActiveTime;
                var taskModel = new Task(taskObj);
                taskModel.save(function (err, result) {
                    if (err) {
                        Msg.error('Import Task' + taskObj.name, err);
                        deferred.reject(err);
                    }
                    Msg.debug(result.name + ' import success. _id:' + result.id);
                    deferred.resolve(result.id);
                });
            }
        });
    }
    return deferred.promise;
}


function importVersion(versionObj, options) {
    var projectId = options.projectId;
    var deferred = Q.defer();
    if (!versionObj) {
        deferred.resolve(null);
    } else {
        var condition = {
            name: versionObj.name,
            projectId: projectId
        };
        Version.findOne(condition, function (err, version) {
            if (err) {
                Msg.error('Failed create version ' + versionObj.name, err);
                deferred.reject(err);
                return;
            }
            if (version) {
                Msg.debug('Version ' + versionObj.name + ' exist ' + version.id);
                version.lastActiveTime = options.lastActiveTime;
                version.save(function (err, record, numberAffected) {
                    if (err) {
                        Msg.error('Version' + version.name + ' update failed!', err);
                        return;
                    }
                    Msg.debug('Version' + record.name + ' exists, last active time updated, affected' + numberAffected + 'record');
                    deferred.resolve(record.id);
                });
            } else {
                versionObj = extend(versionObj, _.pick(options, ['lastActiveTime', 'createTime', 'projectId']));
                var versionModel = new Version(versionObj);
                versionModel.save(function (err, result) {
                    var name = versionObj.name;
                    if (err) {
                        Msg.error('Import Version' + name, err);
                        deferred.reject(err);
                    }
                    Msg.success('Successfully import version ' + name + ' _id:' + result.id);
                    deferred.resolve(result.id);
                });
            }
        });
    }
    return deferred.promise;
}

exports.importFromLogFile = importFromLogFile;