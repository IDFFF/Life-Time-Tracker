/**
 * import logs to database
 */

'use strict';

var scanner = require('./scanner');
var Q = require('q');
var Moment = require('moment');
var extend = require('extend');
var helper = require('./helper');

/** Models */

var Log = require('./model/log');
var Project = require('./model/project');
var ProjectObject = require('./model/fundament/Project');
var Task = require('./model/Task');
var Version = require('./model/version');
var Tag = require('./model/tag');



//var syncNoteSig = require('./globalSignals').syncNote;
var Msg = require('./message');
var _ = require('lodash');


//import note to database after sync success;
/*syncNoteSig.add(function (files) {
    importFromLogFile({
        files: files
    });
});*/

var importedLogCount = 0;


/**
 * import data from log file into database
 * @param  {Object} options
 * @return {Promise}
 */
function importFromLogFile(options) {
    var deferred = Q.defer();
    //scan the data
    scanner.scan(options)
        .then(function (scanResult) {
            var days = scanResult.days || [scanResult];
            importLogs(days).then(function () {
                deferred.resolve();
            });
        }).then(function () {
            Msg.success('logs have been imported into database successfully.');
        }).catch(function (err) {
            Msg.error('Something wrong happen when imported logs into database.');
            deferred.reject(err);
        });
    return deferred.promise;
}


var waitToImportedLogCount = 0,
    totalNumberRemoved = 0;
function importLogs(days) {
    waitToImportedLogCount = 0;
    totalNumberRemoved = 0;

    var promise = days.reduce(function (promise, day) {
        waitToImportedLogCount += day.logs.length;
        return promise.then(importDay.bind(null, day));
    }, Q(1));
    Msg.info('Import Logs Count:' + waitToImportedLogCount);
    return promise;
}

function importDay(day) {
    var deferred = Q.defer();
    if (_.isEmpty(day)) {
        return Q(1);
    }
    var logs = day.logs;
    var date = day.date;
    if (_.isEmpty(logs)) {
        Msg.warn('[import log]' + date + '\'s have no log');
        return Q(1);
    }

    //remove the same day's log before import
    Log.remove({
        date: new Date(day.date)
    }, function (err, numberRemoved) {
        if (err) {
            Msg.error('清空失败' + date, err);
        }
        if (!numberRemoved) {
            Msg.debug('不需要清空' + date);
        } else {
            Msg.debug('已清空' + date + '的数据' + numberRemoved);
        }
        totalNumberRemoved += numberRemoved;
            //insert sequence, make sure that task will not repeat
        logs.reduce(function(promise, log) {
            return promise.then(importLog.bind(null, date, log));
        }, Q(1)).then(function () {
            deferred.resolve();
            Msg.success('Successfully Import Day ' + date);
        });
    });
    return deferred.promise;
}


function importLog(date, log) {
    var deferred = Q.defer();
    log.project = log.projects[0];
    // import tags
    importTags(log.tags).then(function () {
        //import project
        if (!log.project && log.task) {
            log.project = new ProjectObject('Inbox', {});
        }
        return importProject(log.project, _.pick(log, ['tags', 'classes', 'start', 'end']));
    }).then(function (projectId) {
        //importVersion
        var version = null;
        var projectProgress = null;
        if (projectId) {
            projectProgress = log.project.progress;
        }
        version = log.version;
        if (log.project && log.project.version) {
            version = {name: log.project.version};
        }
        importVersion(version, {
            projectId: projectId,
            createTime: log.start,
            lastActiveTime: log.end
        }).then(function (versionId) {
            //import task;
            importTask(log.task, {
                projectId: projectId,
                versionId: versionId,
                createTime: log.start,
                lastActiveTime: log.end,
                hasSubTasks: !_.isEmpty(log.subTask)
            }).then(function (task) {
                var deferred = Q.defer();
                if (log.subTask) {
                    importTask(log.subTask, {
                        projectId: projectId,
                        versionId: versionId,
                        createTime: log.start,
                        lastActiveTime: log.end,
                        parent: task
                    }).then(function (subTask) {
                        deferred.resolve({
                            task: task,
                            subTask: subTask
                        });
                    });
                } else {
                    return {
                        task: task
                    };
                }
                return deferred.promise;
            }).then(function (result) {
                var savedTask = result.task,
                    savedSubTask = result.subTask;
                var taskId = null, taskProgress = null;
                if (savedTask && !savedSubTask) {
                    taskId = savedTask._id;
                    taskProgress = savedTask.progress;
                }

                var subTaskId = null, subTaskProgress = null;
                if (savedSubTask) {
                    subTaskId = savedSubTask._id;
                    subTaskProgress = savedSubTask.progress;
                }
                saveLog({
                    project: projectId,
                    task: subTaskId || taskId,
                    subTask: subTaskId,
                    version: versionId,
                    progress: {
                        subTask: subTaskProgress,
                        task: taskProgress,
                        project: projectProgress
                    }
                });

                function saveLog(refer) {
                    var logModel = new Log(_.extend({date: date}, log, refer));
                    logModel.save(function(err, log) {
                        if (err) {
                            Msg.error('Save Log failed!', err);
                        } else {
                            importedLogCount++;
                            //Msg.success('Import Log Success' + log.origin);
                            deferred.resolve();
                        }
                        if (importedLogCount === waitToImportedLogCount) {
                            Msg.success('Import Logs finished, count:' + importedLogCount);
                        }
                    });
                }
            }).catch(function (err) {
                Msg.error('import task of log failed!', err);
            });
        });
    }).catch(function (err) {
        Msg.error('import project fail', err);
    });
    return deferred.promise;
}

function importProject(project, attrs) {
    var tags = attrs.tags,
        classes = attrs.classes;
    var deferred = Q.defer();
    if (!project) {
        deferred.resolve(null);
        return deferred.promise;
    }
    var queryCondition = getProjectQueryCondition(project);
    //check the existence of project
    Project.findOne(queryCondition, function (err, result) {
        if (err) {
            throw err;
        }
        if (!result) {
            project.createdTime = new Moment(attrs.start).toDate();
            project.lastActiveTime = new Moment(attrs.end).toDate();
            project.tags = tags || [];
            project.classes = classes || [];
            var projectModel = new Project(project);
            //save to database
            projectModel.save(function (err, result) {
                if (err) {
                    Msg.error('Project' + ' create failed!' + JSON.stringify(project), err);
                    deferred.reject(err);
                    return;
                }
                Msg.success('Successfully save Project ' + project.name);
                deferred.resolve(result.id);
            });
        } else {
            result.lastActiveTime = new Moment(attrs.end).toDate();
            if (!_.isEmpty(tags)){
                result.tags.addToSet(tags);
            }
            result.attributes = extend(result.attributes, project.attributes);
            //update progress
            if (_.isNumber(project.progress)) {
                result.progress = project.progress;
            }
            var resultClasses = result.classes;
            if (resultClasses && !_.isEmpty(classes)) {
                var appendClasses = [];
                classes.forEach(function (newCls) {
                    var classExist = resultClasses.filter(function (cls) {
                        return cls.code === newCls.code;
                    }).length > 0;
                    if (!classExist) {
                        appendClasses.push(newCls);
                    }
                });
                resultClasses.push.apply(resultClasses, appendClasses);
            }
            result.save(function (err, proj, numberAffected) {
                if (err) {
                    Msg.error('Project' + ' update failed!' + JSON.stringify(project), err);
                    deferred.reject(err);
                    return;
                }
                Msg.debug('Project ' + proj.name + ' exists, last active time updated, affected' + numberAffected + 'record');
                deferred.resolve(proj.id);
            });
        }
    });
    return deferred.promise;
}

function getProjectQueryCondition(project) {
    //var version = project.version;
    var queryCondition = {
        name: project.name,
    };
    /*
    if (version) {
        queryCondition.version = version;
    } else if (exceptVersion) {
        queryCondition.version = {$exists: false};
    }*/
    return queryCondition;
}




function importTask(taskObj, info) {
    var projectId = info.projectId,
        versionId = info.versionId,
        createTime = info.createTime,
        parent = info.parent,
        lastActiveTime = info.lastActiveTime;

    function appendInfo(taskObj) {
        if (taskObj.progress === 100 && lastActiveTime) {
            taskObj.completeTime = new Moment(lastActiveTime).toDate();
        }
        taskObj.projectId = projectId;
        taskObj.versionId = versionId;
        taskObj.createTime = createTime;
        taskObj.lastActiveTime = lastActiveTime;
        taskObj.parent = parent ? parent.id : null;
        return taskObj;
    }


    var deferred = Q.defer();
    if (!taskObj) {
        deferred.resolve({});
    } else {
        var condition = {name: taskObj.name};
        if (projectId) {
            condition.projectId = projectId;
        }
        if (versionId) {
            condition.versionId = versionId;
        }
        if (parent) {
            condition.parent = parent._id;
        } else {
            condition.parent = { $type: 10 };
        }
        Task.findOne(condition, function (err, task) {
            //if task already exist
            if (task) {
                Msg.debug('Task ' + taskObj.name + ' exist ');
                task.lastActiveTime = lastActiveTime;
                task.attributes = extend(task.attributes, taskObj.attributes);
                if (_.isNumber(taskObj.progress)) {
                    task.progress = taskObj.progress;
                    if (taskObj.progress === 100 && lastActiveTime) {
                        task.completeTime = new Moment(lastActiveTime).toDate();
                    }
                }
                task.save(function (err, result, numberAffected) {
                    if (err) {
                        Msg.error('Task' + task.name + ' update failed!', err);
                        return;
                    }
                    Msg.debug('Task ' + task.name + ' exists, last active time updated, affected' + numberAffected + 'record');
                    addToParent(parent, result, function () {
                        deferred.resolve(result);
                    });
                });
            } else {
                taskObj = appendInfo(taskObj);
                var taskModel = new Task(taskObj);
                taskModel.save(function (err, result) {
                    if (err) {
                        //Msg.error('Import Task' + taskObj.name, err);
                        return deferred.reject(err);
                    }
                    Msg.debug(result.name + ' import success. _id:' + result.id);
                    addToParent(parent, result, function () {
                        deferred.resolve(result);
                    });
                });
            }
        });
    }

    function addToParent(parent, child, cb) {
        if (!parent) {
            return cb();
        }
        parent.children.addToSet(child._id);
        parent.save(function (err, result) {
            if (err) {
                throw err;
            }
            cb(result);
        });
    }
    return deferred.promise;
}



function importVersion(versionObj, options) {
    var projectId = options.projectId;
    var deferred = Q.defer();
    if (!versionObj) {
        deferred.resolve(null);
    } else {
        var condition = {
            name: versionObj.name,
            projectId: projectId
        };
        Version.findOne(condition, function (err, version) {
            if (err) {
                Msg.error('Failed create version ' + versionObj.name, err);
                deferred.reject(err);
                return;
            }
            if (version) {
                Msg.debug('Version ' + versionObj.name + ' exist ' + version.id);
                version.attributes = extend(version.attributes, versionObj.attributes);
                version.lastActiveTime = options.lastActiveTime;
                version.save(function (err, record, numberAffected) {
                    if (err) {
                        Msg.error('Version' + version.name + ' update failed!', err);
                        return;
                    }
                    Msg.debug('Version' + record.name + ' exists, last active time updated, affected' + numberAffected + 'record');
                    deferred.resolve(record.id);
                });
            } else {
                versionObj = extend(versionObj, _.pick(options, ['lastActiveTime', 'createTime', 'projectId']));
                var versionModel = new Version(versionObj);
                versionModel.save(function (err, result) {
                    var name = versionObj.name;
                    if (err) {
                        Msg.error('Import Version' + name, err);
                        deferred.reject(err);
                    }
                    Msg.success('Successfully import version ' + name + ' _id:' + result.id);
                    deferred.resolve(result.id);
                });
            }
        });
    }
    return deferred.promise;
}


function importTags (tags) {
    if (!tags) {
        return Q(1);
    }
    if (!_.isArray(tags)) {
        tags = [tags];
    }
    return tags.reduce(function (promise, tag) {
        return promise.then(importTag(tag));
    }, Q(1));
}

function importTag (tag) {
    var deferred = Q.defer();
    Tag.count({name: tag}, function (err, count) {
        if (err) {
            return deferred.reject(err);
        }
        if (count === 0) {
            Tag.create({name: tag}, function (err, tag) {
                if (err) {
                    return deferred.reject(err);
                }
                Msg.success('Import tag success');
                deferred.resolve(true);
            });
        } else {
            return deferred.resolve(false);
        }
    });
    return deferred.promise;
}



exports.importFromLogFile = importFromLogFile;
exports.importLogContent = function (date, logContent) {
    var logs;
    try {
        logs = helper.getLogs(logContent, date);
    } catch(e) {
        console.error(e.stack);
        return Q({});
    }
    return importDay({
        logs: logs,
        date: date
    });
};