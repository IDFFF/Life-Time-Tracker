/**
 * export data
 */
'use strict';

var Search = require('./search/search');
var Q = require('q');
var Moment = require('moment');
var _ = require('lodash');
var Msg = require('./message');


exports.export = function (options) {
    var deferred = Q.defer();
    Search.query(options).then(function (logs) {
        var days = [],
            oneDayOriginLogs = [],
            logsEndIndex = logs.length - 1,
            currentDate = null,
            prevDate = null;
        //category logs into it's belong day
        logs.forEach(function (log, index) {
            var date = new Moment(log.date).format('YYYY-MM-DD');
            currentDate = date;
            var isSameDay = index > 0 && currentDate === prevDate;
            var str = getExportLogString(log);
            if (index === 0) {
                oneDayOriginLogs.push(str);
            } else if (isSameDay) {
                oneDayOriginLogs.push(str);
            }
            //if day over, then push the data into days array
            var isDayOver = (prevDate !== null && prevDate !== currentDate ||
                index === logsEndIndex);
            if(isDayOver){
                days.push({
                    date: prevDate || currentDate,
                    content: oneDayOriginLogs.join('\n')
                });
                //initialize the next day
                oneDayOriginLogs = [getExportLogString(log)];
            }
            prevDate = currentDate;
        });
        deferred.resolve(days);
    }).catch(function (err) {
        Msg.error('exportor error!', err);
    });
    return deferred.promise;
};


function getExportLogString(log) {
    var str = [
        getTimeStr(log.start, log.end),
        getLogClassStr(log.classes),
        getTagStr(log.tags),
        getSignStr(log.signs),
        getProjectStr(log.project),
        getTaskStr(log.task),
        getSubTaskStr(log.subTask),
        log.content || ''
    ].filter(function (val) {
        return !!val;
    }).join(' ');
    return str;

    function getTimeStr (start, end) {
        var timeFormat = 'HH:mm';
        start =  new Moment(start);
        end = new Moment(end);
        return start.diff(end) > 0 ? [
            start.format(timeFormat),
            end.format(timeFormat)
        ].join('~') : start.format(timeFormat);
    }

    function getLogClassStr(classes) {
        if (_.isEmpty(classes)) {
            return '';
        } else {
            return '{' + classes.map(function (cls) {
                return cls.code;
            }).join(',') + '}';
        }
    }

    function getTagStr(tags) {
        var str;
        if (_.isEmpty(tags)) {
            str =  '';
        } else {
            str = '[' + tags.join(',') + ']';
        }
        return str;
    }

    function getSignStr(signs) {
        var str;
        if (_.isEmpty(signs)) {
            str =  '';
        } else {
            str = '`' + signs.join(',') + '`';
        }
        return str;
    }

    function getProjectStr(project) {
        return getObj(project, '<', '>');
    }

    function getTaskStr (task) {
        return getObj(task, '(', ')');
    }

    function getSubTaskStr(subTask) {
        return getObj(subTask, '#', '#');
    }

    function getObj(item, prefix, suffix) {
        if (!item) {
            return '';
        }
        var attrs = getAttrsStr(item.attributes);
        var tpl = _.template(prefix + '<%=name%><%=attrs ? ":" + attrs : ""%>' + suffix);
        var str = tpl({
            name: item.name,
            id: item._id.toString(),
            attrs: attrs
        });
        return str;
    }

    function getAttrsStr(attrs) {
        if (_.isEmpty(attrs)) {
            attrs = '';
        } else {
            attrs = _.map(attrs, function (value, key) {
                return key + '=' + value;
            }).join(' ');
        }
    }
}