'use strict';

var fs = require('fs');
var mkdirp = require('mkdirp');
var Evernote = require('evernote').Evernote;
var config = require('../conf/config').get();
var Msg = require('../message');
var ProgressBar = require('progress');
var path = require('path');
var moment = require('moment');
//var syncNoteSig = require('../globalSignals').syncNote;
var Q = require('q');
var _ = require('lodash');
var Encoder = require('node-html-encoder').Encoder;
var Moment = require('moment');
// entity type encoder
var encoder = new Encoder('entity');


var EVERNOTE_SERVER_ERROR = '同步evernote服务器发生故障';
var EVENT_NOTEBOOK_NAME = 'Event Log';
var authToken  = require('../conf/token.json').evernote;

var logDir = path.normalize(config.logDir);

if (logDir.lastIndexOf('/') === logDir.length - 1) {
    logDir = logDir.slice(0, logDir.length - 1);
}
var resolvedPath = path.resolve(logDir);
var isAbsolutePath = resolvedPath === logDir;
var LOG_FILE_EXTENSION = 'md', logsPath;
if (isAbsolutePath) {
    logsPath = logDir + '/';
} else {
    logsPath = path.resolve(__dirname, '../' + logDir) + '/';
}

var client = new Evernote.Client({
    token: authToken,
    sandbox: false
});
var noteStore = client.getNoteStore();



function syncNote(client, options, onSuccess) {
    var start = new Moment(options.start),
        end = new Moment(options.end);

    var status = {
        finished: false
    };

    // List all of the notebooks in the user's account
    noteStore.listNotebooks(function(err, notebooks) {
        if (err) {
            Msg.error(EVERNOTE_SERVER_ERROR + ' 访问限制', err);
            return;
        }
        notebooks.forEach(function(notebook) {
            if (notebook.name === EVENT_NOTEBOOK_NAME) {
                Msg.log('notebook exsit guid = ' + notebook.guid);
                findEventLog(notebook, start, end, function (result) {
                    status.finished = true;
                    onSuccess(result);
                    //syncNoteSig.dispatch(downloadSuccessNotes, downloadFailNotes);
                });
            }
        });
    });

    return status;

}
function findEventLog(notebook, start, end, callback) {
    var filter = new Evernote.NoteFilter(),
        spec = new Evernote.NotesMetadataResultSpec();
    spec.includeTitle = true;
    spec.includeCreated = true;
    spec.includeUpdated = true;
    filter.notebookGuid = notebook.guid;
    noteStore.findNotesMetadata(filter, 0, 35600, spec, function(err, result) {
        if (err) {
            Msg.error(EVERNOTE_SERVER_ERROR, err);
            throw err;
        }

        var notes = result.notes;
        var downloadNotes = notes.filter(function(note) {
            return note.title && needDownload(note.title, start, end);
        });
        //result.totalNotes
        if (downloadNotes.length > 0) {
            Msg.success('一共找到' + downloadNotes.length + '个笔记符合同步条件.');
        } else {
            Msg.warn('没有找到符合条件的笔记.');
        }
        var bar = new ProgressBar('Downloading [:bar] :percent', {
            complete: '=',
            incomplete: ' ',
            total: downloadNotes.length
        });
        var downloadFailNotes = [],
            downloadSuccessNotes = [],
            loadedCount = 0,
            writeFailedNotes = [],
            totalNotes = downloadNotes.length;
        downloadNotes.forEach(function(note) {
            noteStore.getNote(authToken, note.guid, true, false, false, false, function(err, result) {
                if (err) {
                    downloadFailNotes.push(note);
                    Msg.error('下载日志失败' + note, err);
                    return;
                }
                var noteTitle = note.title;

                var content = encoder.htmlDecode(result.content);
                content = stripENML(content);
                var dateArr = noteTitle.split('-').map(function(val) {
                    return parseInt(val);
                });
                var path = logsPath + dateArr.slice(0, 2).join('/');
                //mkdir is the directory is not exist;
                mkdirp(path, function(err) {
                    if (err) {
                        throw err;
                    }
                    var file = path + '/' + dateArr[2] + '.' + LOG_FILE_EXTENSION;
                    fs.writeFile(file, content, function(err) {
                        if (err) {
                            writeFailedNotes.push(noteTitle);
                            Msg.error('写文件' + noteTitle + '错误', err);
                            return;
                        }
                        var failLoadCount = downloadFailNotes.length;
                        if (failLoadCount + loadedCount === totalNotes) {
                            Msg.success('同步文件完成');
                            if (failLoadCount > 0) {
                                Msg.error('同步失败的文件:' + downloadFailNotes.join(','));
                            }
                            if (writeFailedNotes.length > 0) {
                                Msg.error('下载成功，但写失败文件:' + writeFailedNotes.join(','));
                            }
                            if (_.isFunction(callback)) {
                                callback({
                                    success: true,
                                    downloadFailNotes: downloadFailNotes,
                                    writeFailedNotes: writeFailedNotes
                                });
                            }
                        }
                    });
                });
                bar.tick(1);
                downloadSuccessNotes.push(noteTitle);
                loadedCount++;
            });
        });
    });
}

function needDownload(noteTitle, start, end) {
    var needFlag = false;
    var matchResult = noteTitle.match(/^(\d{4})-(\d{1,2})-(\d{1,2})\s*$/);

    if (matchResult) {
        var matchResultArr = matchResult.slice(1).map(function(v) {
            return parseInt(v, 10);
        });
        var matchDate = matchResultArr.join('-');
        needFlag = isDateInDateRange(matchDate);
    }
    return needFlag;

    function isDateInDateRange(targetDate) {
        var midTime = ' 00:00:00';
        var targetMoment = new moment(targetDate + midTime);
        return targetMoment.diff(start) >= 0 &&
                targetMoment.diff(end) <= 0;
    }
}

function stripENML(content) {
    var bodyRegexp = /<en-note.*?>([\s\S]*?)<\/en-note>/g;
    var body = bodyRegexp.exec(content)[1];
    body = body.replace(/<\/?div.*?>/g, '');
    body = body.replace(/<\/?span.*?>/g, '');
    body = body.replace(/<\/?a.*?>/g, '');
    body = body.replace(/<\/?p.*?>/g, '');
    body = body.replace(/<br\/>/g, '');
    body = body.replace(/\&gt;/g, '>');
    body = body.replace(/\&lt;/g, '<');
    body = body.replace(/\&quot;/g, '"');

    return body;
}


function getFilePath(dateStr) {
    var path;
    var dateArr = dateStr.split('-').map(function(val) {
        return parseInt(val);
    });
    path = logsPath + dateArr.slice(0, 2).join('/');
    path += '/' + dateArr[2] + '.' + LOG_FILE_EXTENSION;
    return path;
}


function readLocalLogFileByDate(date) {
    var filePath = getFilePath(date);
    return fs.readFileSync(filePath, {encoding: 'utf8'});
}


/*
// To create a new note, simply create a new Note object and fill in
// attributes such as the note's title.
var note = new Evernote.Note();
note.title = "Test note from EDAMTest.js";

// To include an attachment such as an image in a note, first create a Resource
// for the attachment. At a minimum, the Resource contains the binary attachment
// data, an MD5 hash of the binary data, and the attachment MIME type.
// It can also include attributes such as filename and location.
var image = fs.readFileSync('enlogo.png');
var hash = image.toString('base64');

var data = new Evernote.Data();
data.size = image.length;
data.bodyHash = hash;
data.body = image;

resource = new Evernote.Resource();
resource.mime = 'image/png';
resource.data = data;

// Now, add the new Resource to the note's list of resources
note.resources = [resource];

// To display the Resource as part of the note's content, include an <en-media>
// tag in the note's ENML content. The en-media tag identifies the corresponding
// Resource using the MD5 hash.
var md5 = crypto.createHash('md5');
md5.update(image);
hashHex = md5.digest('hex');

// The content of an Evernote note is represented using Evernote Markup Language
// (ENML). The full ENML specification can be found in the Evernote API Overview
// at http://dev.evernote.com/documentation/cloud/chapters/ENML.php
note.content = '<?xml version="1.0" encoding="UTF-8"?>';
note.content += '<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">';
note.content += '<en-note>Here is the Evernote logo:<br/>';
note.content += '<en-media type="image/png" hash="' + hashHex + '"/>';
note.content += '</en-note>';

// Finally, send the new note to Evernote using the createNote method
// The new Note object that is returned will contain server-generated
// attributes such as the new note's unique GUID.
noteStore.createNote(note, function(err, createdNote) {
    console.log();
    console.log("Creating a new note in the default notebook");
    console.log();
    console.log("Successfully created a new note with GUID: " + createdNote.guid);
});


*/

/**
 * Back up logs to evernote, every backup action will create a notebook
 * notebook name format: 'Ltt.backup.{YYYYMMDDHHmmss} 'Ltt.backup.20141220123412'
 * note name format: {YYYY-MM-DD} example: '2014-10-12'
 * @param  {Array} days
 * @param  {Object} options
 * @return {[type]}         [description]
 */
exports.backup = function (days, options) {
    var deferred = Q.defer();
    options = _.extend({notebookNamePrefix: 'Ltt_back_up'}, options);
    var notebookName = [options.notebookNamePrefix, new moment().format('YYYYMMDDHHmmss')].join('_');
    //create nootBook and backup all files to this notebook
    createNotebook(notebookName).then(function (createdNoteBook) {
        var notebookGuid = createdNoteBook.guid;
        Msg.success('Successfully created a new backup notebook '+ notebookName + ' with GUID' + notebookGuid);
        Q.allSettled(days.map(function (day) {
            var date = new moment(day.date)
            var title = date.format('YYYY-MM-DD');
            return createNote(title, day.content, notebookGuid, date.toDate());
        })).then(function (promises) {
            var failedDays = [];
            promises.forEach(function (promise) {
                if (promise.state === 'rejected'){
                    failedDays.push(promise.value);
                }
            });
            deferred.resolve({success: true, failedDays: failedDays});
        });
    }).catch(function (err) {
        Msg.error('sync error create notebook ' + notebookName + ' failed!', err);
        deferred.reject({success: false, error: err});
    });
    return deferred.promise;
};

function createNotebook(name) {
    var deferred = Q.defer();
    var notebook = new Evernote.Notebook();
    notebook.name = name;
    noteStore.createNotebook(authToken, notebook, function (err, notebook) {
        if (err) {
            deferred.reject(err);
            return;
        }
        deferred.resolve(notebook);
    });
    return deferred.promise;
}

/**
 * create note
 * @param  {String} title
 * @param  {String} content 日志内容
 */
function createNote(title, content, notebookGuid, createDate) {
    var deferred = Q.defer();
    var note = new Evernote.Note();
    note.title = title;
    note.content = getNoteContent(content);
    note.notebookGuid = notebookGuid;
    if (_.isDate(createDate)) {
        note.created = createDate.getTime();
    }
    noteStore.createNote(note, function (err, createdNote) {
        if (err) {
            Msg.error('note ' + note.title + ' save to evernote fail!', err);
            deferred.reject(err);
            return;
        }
        Msg.debug('Successfully backup ' + title);
        deferred.resolve(createdNote);
    });
    return deferred.promise;
}

function getNoteContent(content) {
    var nBody = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
    nBody += "<!DOCTYPE en-note SYSTEM \"http://xml.evernote.com/pub/enml2.dtd\">";
    nBody += "<en-note>" + transformToENML(content)+ "</en-note>";
    return nBody;
}

function transformToENML(content) {
    return content.split('\n').map(function (line) {
        return '<div>' + encoder.htmlEncode(line) + '</div>';
    }).join('\n');
}


exports.sync = function (options) {
    var deferred = Q.defer();

    var userStore = client.getUserStore();

    userStore.checkVersion(
        "Evernote EDAMTest (Node.js)",
        Evernote.EDAM_VERSION_MAJOR,
        Evernote.EDAM_VERSION_MINOR,
        function(err, versionOk) {
            var status;
            var syncCount = 0;
            if (err) {
                Msg.error(EVERNOTE_SERVER_ERROR, err);
                deferred.reject(err);
                return;
            }
            Msg.info("Is my Evernote API version up to date? " + versionOk);
            if (!versionOk) {
                process.exit(1);
            }
            if (options.interval !== undefined) {
                syncIntervaly();
                setInterval(syncIntervaly, options.interval);
            } else {
                syncNote(client, options, function (result) {
                    deferred.resolve(result);
                });
            }
            function syncIntervaly() {
                if (!status || status.finished) {
                    status = syncNote(client, options);
                    syncCount++;
                    Msg.info('同步序号:' + syncCount + ', 同步时间: ' + moment().format('YYYY-MM-DD HH:mm:ss'));
                }
            }
        }
    );

    return deferred.promise;
};


exports.backUpLogFile = function (date, logContent) {
    var deferred = Q.defer();
    var notebookGuid;
    var promise;
    if (!logContent) {
        logContent="";
    }
    date = new Moment(date).format('YYYY-MM-DD');
    findNoteBook(EVENT_NOTEBOOK_NAME)
    .then(function (notebook) {
        if (!notebook) {
            console.log('note book not exist'.red);
            throw new Error(EVENT_NOTEBOOK_NAME +  ' notebook does not exist.');
        }
        console.log('$$$$$$$', notebook);
        notebookGuid = notebook.guid;
        console.error('find book guid ' + notebookGuid);
        return findNote(date, notebookGuid);
    }).then(function (note) {
        console.log('saving note', note);
        return saveNote(note, notebookGuid);
    }).catch(function (err) {
        Msg.error('backup log to evernote failed!', err);
        deferred.reject(err);
    });

    function saveNote(note, notebookGuid) {
        var promise;
        if (note) {
            console.log('update note');
            promise = updateNote(note, logContent);
        } else {
            console.log('create note');
            promise = createNote(date, logContent, notebookGuid, new Moment(date).toDate());
        }
        promise.then(function (result) {
            deferred.resolve(result);
            console.log('update success');
        });
        return promise;
    }
    return deferred.promise;
};


exports.backUpLogFileByDate = function (date) {
    var content = readLocalLogFileByDate(date);
    return exports.backUpLogFile(date, content);
};

function updateNote(noteMeta, logContent) {
    var deferred = Q.defer();
    var note = new Evernote.Note();
    note.title = noteMeta.title;
    note.guid = noteMeta.guid;
    note.content = getNoteContent(logContent);
    note.notebookGuid = noteMeta.notebookGuid;
    noteStore.updateNote(note, function (err, result) {
        if (err) {
            return deferred.reject(err);
        }
        deferred.resolve(result);
    });
    return deferred.promise;
}


function findNoteBook(notebookName) {
    var deferred = Q.defer();
    var target = null;
    // List all of the notebooks in the user's account
    noteStore.listNotebooks(function(err, notebooks) {
        if (err) {
            Msg.error(EVERNOTE_SERVER_ERROR + ' 访问限制', err);
            deferred.reject(err);
            return;
        }
        notebooks.some(function(notebook) {
            //console.log('###### '  + notebook.name);
            if (notebook.name === notebookName) {
                //console.log(notebook);
                Msg.log('notebook found. guid = ' + notebook.guid);
                target = notebook;
            }
        });
        deferred.resolve(target);
    });
    return deferred.promise;
}

function listAllNote(notebook) {
    var deferred = Q.defer();
    var filter = new Evernote.NoteFilter(),
        spec = new Evernote.NotesMetadataResultSpec();
    spec.includeTitle = true;
    spec.includeCreated = true;
    spec.includeUpdated = true;
    spec.includeNotebookGuid = true;
    filter.notebookGuid = notebook.guid;
    noteStore.findNotesMetadata(filter, 0, 35600, spec, function(err, result) {
        if (err) {
            return deferred.reject(err);
        }
        deferred.resolve(result.notes);
    });
    return deferred.promise;
}


function findNote(noteTitle, notebookGuid) {
    console.log('find note:' + noteTitle + ' in ' + notebookGuid);
    var deferred = Q.defer();
    var filter = new Evernote.NoteFilter(),
        spec = new Evernote.NotesMetadataResultSpec();
    spec.includeTitle = true;
    spec.includeCreated = true;
    spec.includeUpdated = true;
    spec.includeNotebookGuid = true;
    filter.notebookGuid = notebookGuid;
    noteStore.findNotesMetadata(filter, 0, 60000, spec, function(err, result) {
        if (err) {
            return deferred.reject(err);
        }
        var notes = result.notes;
        console.log(noteTitle, notes.length);
        var target = notes.filter(function(note) {
            return note.title === noteTitle;
        });
        console.log('find note : ' + target.length);
        if (target.length > 1) {
            return deferred.reject(new Error('dumplicate note of ' + noteTitle));
        }
        deferred.resolve(target[0]);
    });
    return deferred.promise;
}


function getAllFile() {
    var result = [];
    var years = fs.readdirSync(logsPath);
    years.forEach(function (year) {
        var months = fs.readdirSync(logsPath + '/' + year);
        months.forEach(function (month) {
            var days = fs.readdirSync([logsPath, year, month].join('/'));
            days.forEach(function(day) {
                var stats = fs.statSync([logsPath, year, month, day].join('/'));
                day = path.basename(day, '.' + LOG_FILE_EXTENSION);
                var date = new Moment([year, month, day].join('-'));
                if (date.isValid()) {
                    result.push({
                        title: date.format('YYYY-MM-DD'),
                        modifiedTime: stats.mtime
                    });
                }
            });
        });
    });
    return result;
}

exports.checkSyncStatus = function () {
    var deferred = Q.defer();
    var unsyncDates = [];

    findNoteBook(EVENT_NOTEBOOK_NAME).then(function (notebook) {
        return listAllNote(notebook);
    }).then(function (notes){
        var files = getAllFile();
        var file, note, noteTitle, exist, fileModifiedTimeUnix, noteModifiedTimeUnix;
        for (var i = 0, fileLen = files.length; i < fileLen; i++) {
            file = files[i];
            fileModifiedTimeUnix = file.modifiedTime.getTime();
            exist = false;
            for (var j = 0, noteLen = notes.length; j < noteLen; j++) {
                note = notes[j]
                noteTitle = note.title;
                noteModifiedTimeUnix = new Date(notes[j].updated).getTime();

                if (noteTitle === file.title && fileModifiedTimeUnix <= noteModifiedTimeUnix) {
                    exist = true;
                    break;
                }
            }
            if (exist === false) {
                unsyncDates.push(file.title);
            }
        }
        deferred.resolve(unsyncDates);
    }).catch(function (err) {
        Msg.error('checkNoUpdateFile failed', err);
        deferred.reject(err);
    });
    return deferred.promise;
};


