/**
 * back up logs, make sure the data savety
 * have different Storage location(remote and local)
 *   - local disk
 *   - remote
 *     + evernote
 *     + dropbox (todo)
 */
'use strict';

var evernote = require('../sync/evernote');
var _ = require('lodash');
var extend = require('node.extend');
var Q = require('q');
var exporter = require('../exporter');
var Msg = require('../message');


var backUp = {
    evernote: function (days) {
        return evernote.backup(days);
    }
};


/**
 * backup
 * @param  {Object} options
 */
exports.backup = function (options) {
    var deferred = Q.defer();
    options = extend(true, {
        locations: ['local', 'evernote']
    }, options);

    exporter.export(options).then(function (days) {
        var backupFailedLocations = [];
        var backUpLocations = options.locations;
        //back up data to all storage location
        var backupPromises = backUpLocations.map(function (location) {
            var backUpHandler = backUp[location];
            if (_.isFunction(backUpHandler)) {
                return backUpHandler.call(null, days)
                    .then(function (result) {
                        Msg.success('Successfully back up ' + (days.length - result.failedDays.length) +
                            'notes to ' + location);
                        if (!_.isEmpty(result.failedDays)) {
                            Msg.warn('Backup fail days: ' + result.failedDays.join(','));
                        }
                        return location;
                    }).catch(function (err) {
                        backupFailedLocations.push(location);
                        Msg.error('Fail back up to ' + location, err);
                    });
            } else {
                Msg.warn('Do not have back up location ' + location);
            }
        }).filter(function (val) { return val !== undefined;});

        Q.allSettled(backupPromises).then(function (promises) {
            var failed = promises.length === backupFailedLocations.length;
            deferred.resolve({
                success: !failed,
                backupFailedLocations: backupFailedLocations
            });
        });
    });
    return deferred.promise;
};