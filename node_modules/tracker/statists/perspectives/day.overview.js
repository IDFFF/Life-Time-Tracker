/**
 * life overview perspective
 */
'use strict';

var msg = require('../../message');
var helper = require('../../helper');
var _ = require('lodash');
var logFileHelper = require('../../logFileHelper');
var Moment = require('moment');
var dateFormat = 'YYYY-MM-DD';

exports.focus = function (options, scanResult) {
    if (!scanResult) {
        throw new Error('no scan result');
    }
    var date = options.dateStr,
        logs = scanResult.logs,
        trackedTime = 0,
        wakeMoment,
        lastMoment,
        sleepMoment;
    var statResult = {
        date: date,
        options: scanResult.options,
        logs: scanResult.logs
    };

    //check the correctness of time frequence for the logs
    helper.checkLogSequence(logs);
    statResult.classes = helper.getLogClassesFromDays([scanResult]).sort(frequenceDesc);
    statResult.tags = helper.getTagsFromDays([scanResult]).sort(frequenceDesc);
    statResult.projects = helper.getAllProjects([scanResult]);

    //last index of the logs
    var lastIndex = logs.length - 1;
    logs.forEach(function(log, index) {
        var signs = log.signs;
        if (signs.indexOf('wake') >= 0) {
            wakeMoment = log.start;
        } else if (signs.indexOf('sleep') >= 0){
            sleepMoment = log.start;
        } else if (signs.indexOf('off') >= 0) {
            statResult.offDutyMoment = log.start;
        }
        if (log.len !== undefined) {
            trackedTime += log.len;
        }
        if (lastIndex === index) {
            lastMoment = log.end;
        }
    });

    console.log('wake', wakeMoment);
    console.log('sleepMoment', sleepMoment);

    //calculate the activeTime and unTrackedTime
    var activeTime = 0, unTrackedTime;
    activeTime = helper.timeSpan(wakeMoment, sleepMoment || lastMoment);
    unTrackedTime = activeTime - trackedTime;
    //validate the activeTime and unTrackedTime
    checkActiceTime(activeTime, unTrackedTime);

    //store the stat result
    statResult.trackedTime = trackedTime;
    statResult.wakeMoment = wakeMoment;
    statResult.sleepMoment = sleepMoment;
    statResult.activeTime = activeTime;
    statResult.unTrackedTime = unTrackedTime;
    statResult.sleepTime = calculateSleepTime(date, sleepMoment);
    statResult.classTime = helper.groupTimeByLogClass(logs, statResult.classes);
    statResult.tagTime = helper.groupTimeByTag(logs);
    statResult.projectTime = helper.groupTimeByProject(logs);
    return statResult;
    function frequenceDesc(a, b) {
        return b.frequence - a.frequence;
    }

    function checkActiceTime(activeTime, unTrackedTime) {
        if (unTrackedTime < 0) {
            msg.error(date + '\'s trackedTime is bigger than activeTime, that\'s impossible. ' + 'trackedTime = ' + trackedTime + ' activeTime = ' + activeTime);
        } else if (unTrackedTime > 200) {
            msg.warn(date + '\'s untrackedTime is too much untrackedTime = ' + unTrackedTime);
        }
    }
};

function calculateSleepTime(date, sleepMoment) {
    var timeSpan = -1;
    /**
    readLogFromDB().then(function (data) {
        var logs = data.logs;
        if (data.logs.length === 0) {
            logs = readLogFromFile(date);
        }
        return logs;
    }).then(function (logs) {
        var wokeTime = getWakeTime(logs);
        timeSpan = getTimeSpan(sleepMoment, wokeTime);
        return timeSpan;
    });*/

    var logs = readLogFromFile(date);
    if (!_.isEmpty(logs)) {
        var wokeTime = helper.getWakeTime(logs);
        timeSpan = helper.timeSpan(sleepMoment, wokeTime);
    }
    return timeSpan;
    function readLogFromFile(date) {
        var nd = nextDay(date);
        var file;
        try {
            file = logFileHelper.readLogFilesSync(nd);
            return helper.getLogs(file.data, nd);
        } catch (e) {
            if (e.code === 'ENOENT') {
                msg.warn('Do not have enough data to calculate sleep lenth of ' + date);
            } else {
                msg.error('error occur when calculate sleep time of ' + date);
                throw e;
            }
        }
    }
}

function nextDay(date) {
    return new Moment(date).add(1, 'days').format(dateFormat);
}